/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// i18n.ts
function initializeLanguage(userPreference) {
  var _a;
  if (userPreference) {
    currentLanguage = userPreference;
    return;
  }
  const systemLang = navigator.language || ((_a = navigator.languages) == null ? void 0 : _a[0]);
  if (systemLang == null ? void 0 : systemLang.startsWith("ru")) {
    currentLanguage = "ru";
  } else {
    currentLanguage = "en";
  }
}
function setLanguage(language) {
  currentLanguage = language;
}
function getSupportedLanguages() {
  return [
    { code: "ru", name: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "en", name: "English" }
  ];
}
function t(key) {
  const keys = key.split(".");
  let value = translations[currentLanguage];
  for (const k of keys) {
    if (value && typeof value === "object" && k in value) {
      value = value[k];
    } else {
      console.warn(`Translation key not found: ${key}`);
      return key;
    }
  }
  return typeof value === "string" ? value : key;
}
function tWithParams(key, params) {
  let translation = t(key);
  for (const [paramKey, paramValue] of Object.entries(params)) {
    translation = translation.replace(
      new RegExp(`\\{${paramKey}\\}`, "g"),
      String(paramValue)
    );
  }
  return translation;
}
var ru, en, translations, currentLanguage;
var init_i18n = __esm({
  "i18n.ts"() {
    ru = {
      common: {
        ok: "\u041E\u041A",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        skip: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
        save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C",
        loading: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430...",
        error: "\u041E\u0448\u0438\u0431\u043A\u0430",
        success: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E",
        type: "\u0422\u0438\u043F",
        status: "\u0421\u0442\u0430\u0442\u0443\u0441"
      },
      modals: {
        searchTitle: "\u{1F37F} \u041F\u043E\u0438\u0441\u043A \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
        searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u043A\u043B\u044E\u0447\u0435\u0432\u043E\u043C\u0443 \u0441\u043B\u043E\u0432\u0443",
        searchButton: "\u041D\u0430\u0439\u0442\u0438",
        searching: "\u041F\u043E\u0438\u0441\u043A...",
        enterMovieName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        needApiToken: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        loadingMovieInfo: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u0442\u0441\u044F \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435...",
        preparingImages: "\u041F\u043E\u0434\u0433\u043E\u0442\u043E\u0432\u043A\u0430 \u043A \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
        movieInfoLoaded: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u0444\u0438\u043B\u044C\u043C\u0435 \u0437\u0430\u0433\u0440\u0443\u0436\u0435\u043D\u0430!",
        errorMovieData: "\u041E\u0448\u0438\u0431\u043A\u0430: \u043D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u043C\u0430",
        errorUnexpected: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430",
        errorGettingDetails: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0433\u0435\u043E\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u043A\u0430)",
        posterTooltipMissing: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442",
        posterTooltipEmptyLink: "\u041F\u0443\u0441\u0442\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
        posterTooltipInvalidLink: "\u041D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u0430\u044F \u0441\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 \u043F\u043E\u0441\u0442\u0435\u0440",
        selectImagesToDownload: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
        selectImagesDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435, \u043A\u0430\u043A\u0438\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E. \u041D\u0435\u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0431\u0443\u0434\u0443\u0442 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043A\u0438.",
        posterImage: "\u041F\u043E\u0441\u0442\u0435\u0440",
        coverImage: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430/\u0424\u043E\u043D",
        logoImage: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F",
        selectImages: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438:",
        imageAvailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u0433\u0440\u0443\u0437\u043A\u0438",
        imageNotAvailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E",
        imageNotAvailableDesc: "\u042D\u0442\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u0438\u0437 API",
        imageUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E",
        downloadPoster: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440",
        downloadCover: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0443",
        downloadLogo: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        continue: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C",
        // Image Approval Modal
        approveImage: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
        approveImageDesc: "\u0412\u0430\u043C \u043D\u0440\u0430\u0432\u0438\u0442\u0441\u044F \u044D\u0442\u043E \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435?",
        selectAlternativeDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435, \u043A\u043E\u0442\u043E\u0440\u043E\u0435 \u0432\u0430\u043C \u043D\u0440\u0430\u0432\u0438\u0442\u0441\u044F, \u0438\u0437 \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432",
        previousImage: "\u041F\u0440\u0435\u0434\u044B\u0434\u0443\u0449\u0435\u0435",
        nextImage: "\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0435",
        showAlternatives: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u044B",
        skip: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
        approve: "\u041E\u0434\u043E\u0431\u0440\u0438\u0442\u044C",
        selectThis: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u044D\u0442\u043E",
        loadingAlternativeImages: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0430\u043B\u044C\u0442\u0435\u0440\u043D\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439...",
        rateMovie: "\u041E\u0446\u0435\u043D\u0438\u0442\u0435 \u0444\u0438\u043B\u044C\u043C",
        ratingValue: "\u0417\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u043E\u0446\u0435\u043D\u043A\u0438",
        enterRatingPlaceholder: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043E\u0446\u0435\u043D\u043A\u0443 \u043E\u0442 0 \u0434\u043E 10"
      },
      suggesters: {
        fileListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u0444\u0430\u0439\u043B\u043E\u0432:",
        folderListError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u0438\u0438 \u0441\u043F\u0438\u0441\u043A\u0430 \u043F\u0430\u043F\u043E\u043A:"
      },
      validation: {
        invalidApiToken: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        invalidSearchQuery: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441",
        invalidMovieId: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        invalidPaginationParams: "\u041D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0435 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u044B \u043F\u0430\u0433\u0438\u043D\u0430\u0446\u0438\u0438"
      },
      provider: {
        tokenRequired: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D \u0432 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430\u0445 \u043F\u043B\u0430\u0433\u0438\u043D\u0430",
        enterMovieTitle: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0444\u0438\u043B\u044C\u043C\u0430 \u0438\u043B\u0438 \u0441\u0435\u0440\u0438\u0430\u043B\u0430 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430",
        nothingFound: '\u041F\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0443 "{query}" \u043D\u0438\u0447\u0435\u0433\u043E \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.',
        invalidMovieId: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ID \u0444\u0438\u043B\u044C\u043C\u0430",
        tokenRequiredForMovie: "\u041D\u0435\u043E\u0431\u0445\u043E\u0434\u0438\u043C\u043E \u0443\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 API \u0442\u043E\u043A\u0435\u043D",
        movieInfoError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0444\u0438\u043B\u044C\u043C\u0435",
        tryChangeQuery: "\u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441."
      },
      errorHandler: {
        badRequest: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0432\u0432\u0435\u0434\u0435\u043D\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435.",
        unauthorized: "\u041D\u0435\u0430\u0432\u0442\u043E\u0440\u0438\u0437\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043E\u0441\u0442\u0443\u043F. \u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044C, \u0447\u0442\u043E API \u0442\u043E\u043A\u0435\u043D \u0443\u043A\u0430\u0437\u0430\u043D \u0438 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D.",
        forbidden: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D \u0441\u0443\u0442\u043E\u0447\u043D\u044B\u0439 \u043B\u0438\u043C\u0438\u0442. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        notFound: "\u0414\u0430\u043D\u043D\u044B\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441.",
        tooManyRequests: "\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u043E\u0432. \u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435 \u043D\u0435\u043C\u043D\u043E\u0433\u043E \u0438 \u043F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0441\u043D\u043E\u0432\u0430.",
        internalServerError: "\u0412\u043D\u0443\u0442\u0440\u0435\u043D\u043D\u044F\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        badGateway: "\u0421\u0435\u0440\u0432\u0435\u0440 \u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u0430 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (502 Bad Gateway).",
        serviceUnavailable: "\u0421\u0435\u0440\u0432\u0438\u0441 \u0432\u0440\u0435\u043C\u0435\u043D\u043D\u043E \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D. \u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u0435 \u043F\u043E\u043F\u044B\u0442\u043A\u0443 \u043F\u043E\u0437\u0436\u0435.",
        gatewayTimeout: "\u0421\u0435\u0440\u0432\u0435\u0440 \u043D\u0435 \u043E\u0442\u0432\u0435\u0447\u0430\u0435\u0442. \u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F (504 Gateway Timeout).",
        networkError: "\u041F\u0440\u043E\u0431\u043B\u0435\u043C\u044B \u0441 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435\u043C \u043A \u0438\u043D\u0442\u0435\u0440\u043D\u0435\u0442\u0443. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u0441\u043E\u0435\u0434\u0438\u043D\u0435\u043D\u0438\u0435.",
        unknownStatusError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435 \u043A \u0441\u0435\u0440\u0432\u0435\u0440\u0443 (\u043A\u043E\u0434 {status}). \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        unexpectedError: "\u041F\u0440\u043E\u0438\u0437\u043E\u0448\u043B\u0430 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\u0430\u044F \u043E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0437\u0430\u043F\u0440\u043E\u0441\u0435. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435."
      },
      images: {
        poster: "\u043F\u043E\u0441\u0442\u0435\u0440\u0430",
        cover: "\u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        logo: "\u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430",
        noImagesToDownload: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 \u0434\u043B\u044F \u0441\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u044F",
        downloading: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435",
        downloadingPoster: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0441\u0442\u0435\u0440\u0430...",
        downloadingCover: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043E\u0431\u043B\u043E\u0436\u043A\u0438...",
        downloadingLogo: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u043D\u0438\u0435 \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u0430...",
        completed: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
        completedAllDownloaded: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0412\u0441\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0441\u043A\u0430\u0447\u0430\u043D\u044B",
        completedAlreadyLocal: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0443\u0436\u0435 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u044B\u0435",
        completedWithErrors: "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E! \u0423\u0441\u043F\u0435\u0448\u043D\u043E: {successful}, \u043D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C: {failed}",
        invalidUrl: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 URL: {url}. \u041E\u0436\u0438\u0434\u0430\u043B\u0441\u044F \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 HTTP/HTTPS URL.",
        imageNotFound: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E (404): {url}",
        accessForbidden: "\u0414\u043E\u0441\u0442\u0443\u043F \u0437\u0430\u043F\u0440\u0435\u0449\u0435\u043D (403): {url}",
        serverError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435: {url}",
        timeout: "\u041F\u0440\u0435\u0432\u044B\u0448\u0435\u043D\u043E \u0432\u0440\u0435\u043C\u044F \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435 {timeout}\u043C\u0441",
        downloadedWithErrors: "\u0421\u043A\u0430\u0447\u0430\u043D\u043E: {successful}/{total} \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439. \u041D\u0435\u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435.",
        imagesUnavailable: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435. \u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u044E\u0442\u0441\u044F \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0441\u0441\u044B\u043B\u043A\u0438.",
        processingError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        posterUnavailable: "\u041F\u043E\u0441\u0442\u0435\u0440 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        coverUnavailable: "\u041E\u0431\u043B\u043E\u0436\u043A\u0430 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430 (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        logoUnavailable: "\u041B\u043E\u0433\u043E\u0442\u0438\u043F \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D (\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u0437\u0430\u0431\u043B\u043E\u043A\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u043C \u0440\u0435\u0433\u0438\u043E\u043D\u0435)",
        downloadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043A\u0430\u0447\u0430\u0442\u044C"
      },
      utils: {
        unknownMovie: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0439 \u0444\u0438\u043B\u044C\u043C",
        copyPrefix: "\u041A\u043E\u043F\u0438\u044F",
        templateNotFound: "\u0428\u0430\u0431\u043B\u043E\u043D \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        templateReadError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0444\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430"
      },
      settings: {
        apiToken: "API \u0422\u043E\u043A\u0435\u043D",
        apiTokenDesc: "\u0412\u0430\u043C \u043D\u0443\u0436\u043D\u043E \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u044D\u0442\u043E\u0433\u043E \u043F\u043B\u0430\u0433\u0438\u043D\u0430. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0435\u0441\u043F\u043B\u0430\u0442\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0438 \u0441\u043B\u0435\u0434\u0443\u0439\u0442\u0435 \u0438\u043D\u0441\u0442\u0440\u0443\u043A\u0446\u0438\u044F\u043C.",
        getApiToken: "\u041F\u043E\u043B\u0443\u0447\u0438\u0442\u044C API \u0422\u043E\u043A\u0435\u043D",
        checkToken: "\u041F\u0440\u043E\u0432\u0435\u0440\u0438\u0442\u044C \u0442\u043E\u043A\u0435\u043D",
        checking: "\u041F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C...",
        tokenValid: "\u2705 \u0422\u043E\u043A\u0435\u043D \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D!",
        tokenInvalid: "\u274C \u0422\u043E\u043A\u0435\u043D \u043D\u0435\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u0435\u043D. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u0442\u043E\u043A\u0435\u043D\u0430.",
        tokenError: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0435 \u0442\u043E\u043A\u0435\u043D\u0430. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u043F\u043E\u0437\u0436\u0435.",
        enterToken: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 API \u0442\u043E\u043A\u0435\u043D \u0434\u043B\u044F \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0438",
        imagesHeading: "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
        saveImagesLocally: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u043E",
        saveImagesLocallyDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F \u0432 \u043B\u043E\u043A\u0430\u043B\u044C\u043D\u0443\u044E \u043F\u0430\u043F\u043A\u0443 \u0432\u043C\u0435\u0441\u0442\u043E \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0435\u0431-\u0441\u0441\u044B\u043B\u043E\u043A.",
        imagesFolder: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439",
        imagesFolderDesc: "\u041F\u0430\u043F\u043A\u0430, \u0433\u0434\u0435 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u044B \u0441\u043A\u0430\u0447\u0430\u043D\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F.",
        imagesFolderPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: attachments/TMDB",
        savePosterImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B",
        savePosterImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043F\u043E\u0441\u0442\u0435\u0440\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        saveCoverImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        saveCoverImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043E\u0431\u043B\u043E\u0436\u043A\u0438/\u0431\u044D\u043A\u0434\u0440\u043E\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        saveLogoImage: "\u0421\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B",
        saveLogoImageDesc: "\u0421\u043A\u0430\u0447\u0438\u0432\u0430\u0442\u044C \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u044F\u0442\u044C \u043B\u043E\u0433\u043E\u0442\u0438\u043F\u044B \u0444\u0438\u043B\u044C\u043C\u043E\u0432/\u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        imageFileNameFormat: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F",
        imageFileNameFormatDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439.",
        imageFileNameFormatPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}}_{{id}}_{{type}}",
        moviesHeading: "\u0424\u0438\u043B\u044C\u043C\u044B",
        movieFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0444\u0438\u043B\u044C\u043C\u0430",
        movieFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432.",
        movieFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
        movieFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
        movieFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0444\u0438\u043B\u044C\u043C\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
        movieFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
        movieTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u043C\u043E\u0432",
        movieTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
        movieTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
        exampleTemplate: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0448\u0430\u0431\u043B\u043E\u043D\u0430",
        seriesHeading: "\u0421\u0435\u0440\u0438\u0430\u043B\u044B",
        seriesFileName: "\u0418\u043C\u044F \u0444\u0430\u0439\u043B\u0430 \u0441\u0435\u0440\u0438\u0430\u043B\u0430",
        seriesFileNameDesc: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438 \u0444\u0430\u0439\u043B\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432.",
        seriesFileNamePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: {{nameForFile}} ({{year}})",
        seriesFileLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0444\u0430\u0439\u043B\u043E\u0432 \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
        seriesFileLocationDesc: "\u041D\u043E\u0432\u044B\u0435 \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0435\u0440\u0438\u0430\u043B\u0430\u0445 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0437\u043C\u0435\u0449\u0435\u043D\u044B \u0437\u0434\u0435\u0441\u044C.",
        seriesFileLocationPlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: \u043F\u0430\u043F\u043A\u04301/\u043F\u0430\u043F\u043A\u04302",
        seriesTemplateFile: "\u0424\u0430\u0439\u043B \u0448\u0430\u0431\u043B\u043E\u043D\u0430 \u0434\u043B\u044F \u0441\u0435\u0440\u0438\u0430\u043B\u043E\u0432",
        seriesTemplateFileDesc: "\u0424\u0430\u0439\u043B\u044B \u0431\u0443\u0434\u0443\u0442 \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B \u043A\u0430\u043A \u0448\u0430\u0431\u043B\u043E\u043D\u044B.",
        seriesTemplateFilePlaceholder: "\u041D\u0430\u043F\u0440\u0438\u043C\u0435\u0440: templates/template-file",
        peopleHeading: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043F\u0435\u0440\u0441\u043E\u043D",
        actorsFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0430\u043A\u0442\u0451\u0440\u043E\u0432",
        actorsFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E\u0431 \u0430\u043A\u0442\u0451\u0440\u0430\u0445",
        actorsFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0410\u043A\u0442\u0451\u0440\u044B",
        directorsFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0440\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u043E\u0432",
        directorsFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0440\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u0430\u0445",
        directorsFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0420\u0435\u0436\u0438\u0441\u0441\u0451\u0440\u044B",
        writersFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u043E\u0432",
        writersFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u0430\u0445",
        writersFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442\u044B",
        producersFileLocation: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u043E\u0432",
        producersFileLocationDesc: "\u041F\u0430\u043F\u043A\u0430, \u0432 \u043A\u043E\u0442\u043E\u0440\u043E\u0439 \u0431\u0443\u0434\u0443\u0442 \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C\u0441\u044F \u0437\u0430\u043C\u0435\u0442\u043A\u0438 \u043E \u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u0430\u0445",
        producersFileLocationPlaceholder: "\u041F\u0440\u0438\u043C\u0435\u0440: \u041B\u044E\u0434\u0438/\u041F\u0440\u043E\u0434\u044E\u0441\u0435\u0440\u044B",
        language: "\u042F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430",
        languageDesc: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044F\u0437\u044B\u043A \u0438\u043D\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043F\u043B\u0430\u0433\u0438\u043D\u0430.",
        // Mobile settings
        mobileSettings: "\u041C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
        mobileCoverHeightMultiplier: "\u041C\u043D\u043E\u0436\u0438\u0442\u0435\u043B\u044C \u0432\u044B\u0441\u043E\u0442\u044B \u043E\u0431\u043B\u043E\u0436\u043A\u0438",
        mobileCoverHeightMultiplierDesc: "\u041C\u043D\u043E\u0436\u0438\u0442\u0435\u043B\u044C \u0432\u044B\u0441\u043E\u0442\u044B \u043E\u0431\u043B\u043E\u0436\u043A\u0438 \u0434\u043B\u044F \u043C\u043E\u0431\u0438\u043B\u044C\u043D\u044B\u0445 \u0443\u0441\u0442\u0440\u043E\u0439\u0441\u0442\u0432 (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E: 1.5)"
      },
      status: {
        selectStatus: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u0442\u0430\u0442\u0443\u0441:",
        willWatch: "\u0411\u0443\u0434\u0443 \u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C",
        haveWatched: "\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u043B",
        watching: "\u0421\u043C\u043E\u0442\u0440\u044E",
        dropped: "\u0417\u0430\u0431\u0440\u043E\u0441\u0438\u043B",
        skip: "\u041F\u0440\u043E\u043F\u0443\u0441\u0442\u0438\u0442\u044C",
        useDefault: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0441\u0442\u0430\u0442\u0443\u0441 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
        defaultStatus: "\u0411\u0443\u0434\u0443 \u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C"
      },
      ratings: {
        myRating: "\u041C\u043E\u044F\u041E\u0446\u0435\u043D\u043A\u0430",
        kinopoiskRating: "\u041A\u0438\u043D\u043E\u043F\u043E\u0438\u0441\u043A\u041E\u0446\u0435\u043D\u043A\u0430",
        year: "\u0413\u043E\u0434"
      }
    };
    en = {
      common: {
        ok: "OK",
        cancel: "Cancel",
        skip: "Skip",
        save: "Save",
        loading: "Loading...",
        error: "Error",
        success: "Success",
        type: "Type",
        status: "Status"
      },
      modals: {
        searchTitle: "\u{1F37F} Search movie or TV show",
        searchPlaceholder: "Search by keyword",
        searchButton: "Search",
        searching: "Searching...",
        enterMovieName: "Enter movie or TV show name to search",
        needApiToken: "API token must be specified in plugin settings",
        loadingMovieInfo: "Loading movie information...",
        preparingImages: "Preparing to download images...",
        movieInfoLoaded: "Movie information loaded!",
        errorMovieData: "Error: invalid movie data",
        errorUnexpected: "An unexpected error occurred",
        errorGettingDetails: "An unexpected error occurred while getting movie information",
        posterPlaceholderEmoji: "\u{1F4FD}\uFE0F",
        posterTooltipGeoblock: "Poster unavailable (possibly geo-blocked)",
        posterTooltipMissing: "Poster missing",
        posterTooltipEmptyLink: "Empty poster link",
        posterTooltipInvalidLink: "Invalid poster link",
        selectImagesToDownload: "Select Images to Download",
        selectImagesDesc: "Choose which images you want to download and save locally. Unselected images will use web links.",
        posterImage: "Poster",
        coverImage: "Cover/Backdrop",
        logoImage: "Logo",
        selectImages: "Select images to download:",
        imageAvailable: "Image is available for download",
        imageNotAvailable: "Image not available",
        imageNotAvailableDesc: "This image is not available from the API",
        imageUnavailable: "Image unavailable",
        downloadPoster: "Download Poster",
        downloadCover: "Download Cover",
        downloadLogo: "Download Logo",
        cancel: "Cancel",
        continue: "Continue",
        // Image Approval Modal
        approveImage: "Approve image",
        approveImageDesc: "Do you like this image?",
        selectAlternativeDesc: "Select the image you like from the alternatives",
        previousImage: "Previous",
        nextImage: "Next",
        showAlternatives: "Show alternatives",
        skip: "Skip",
        approve: "Approve",
        selectThis: "Select this",
        loadingAlternativeImages: "Loading alternative images...",
        rateMovie: "Rate the movie",
        ratingValue: "Rating value",
        enterRatingPlaceholder: "Enter rating from 0 to 10"
      },
      suggesters: {
        fileListError: "Error getting file list:",
        folderListError: "Error getting folder list:"
      },
      validation: {
        invalidApiToken: "Invalid API token",
        invalidSearchQuery: "Invalid search query",
        invalidMovieId: "Invalid movie ID",
        invalidPaginationParams: "Invalid pagination parameters"
      },
      provider: {
        tokenRequired: "Valid API token must be specified in plugin settings",
        enterMovieTitle: "Enter movie or TV show title to search",
        nothingFound: 'Nothing found for query "{query}".',
        invalidMovieId: "Invalid movie ID",
        tokenRequiredForMovie: "Valid API token must be specified",
        movieInfoError: "Failed to get movie information",
        tryChangeQuery: "Try changing the search query."
      },
      errorHandler: {
        badRequest: "Bad request. Please check the entered data.",
        unauthorized: "Unauthorized access. Make sure the API token is specified and valid.",
        forbidden: "Daily limit exceeded. Please wait and try again.",
        notFound: "Data not found. Try changing the search query.",
        tooManyRequests: "Too many requests. Please wait a bit and try again.",
        internalServerError: "TMDB server internal error. Try again later.",
        badGateway: "TMDB server temporarily unavailable (502 Bad Gateway).",
        serviceUnavailable: "Service temporarily unavailable. Try again later.",
        gatewayTimeout: "Server not responding. Timeout exceeded (504 Gateway Timeout).",
        networkError: "Internet connection problems. Check your connection.",
        unknownStatusError: "An error occurred when requesting the server (code {status}). Try again later.",
        unexpectedError: "An unexpected error occurred during the request. Try again later."
      },
      images: {
        poster: "poster",
        cover: "cover",
        logo: "logo",
        noImagesToDownload: "No images to download",
        downloading: "Downloading",
        downloadingPoster: "Downloading poster...",
        downloadingCover: "Downloading cover...",
        downloadingLogo: "Downloading logo...",
        completed: "Completed!",
        completedAllDownloaded: "Completed! All images downloaded",
        completedAlreadyLocal: "Completed! Images are already local",
        completedWithErrors: "Completed! Successful: {successful}, failed: {failed}",
        invalidUrl: "Invalid URL format: {url}. Expected valid HTTP/HTTPS URL.",
        imageNotFound: "Image not found (404): {url}",
        accessForbidden: "Access forbidden (403): {url}",
        serverError: "Server error ({status}): {url}",
        httpError: "HTTP {status}: {url}",
        downloadFailed: "Failed to download image: {url}",
        timeout: "Timeout after {timeout}ms",
        downloadedWithErrors: "Downloaded: {successful}/{total} images. Some are unavailable in your region.",
        imagesUnavailable: "Images are unavailable in your region. Using original links.",
        processingError: "Error processing images",
        posterUnavailable: "Poster unavailable (possibly blocked in your region)",
        coverUnavailable: "Cover unavailable (possibly blocked in your region)",
        logoUnavailable: "Logo unavailable (possibly blocked in your region)",
        downloadError: "Failed to download"
      },
      utils: {
        unknownMovie: "Unknown Movie",
        copyPrefix: "Copy",
        templateNotFound: "Template not found",
        templateReadError: "Failed to read template file"
      },
      settings: {
        apiToken: "API Token",
        apiTokenDesc: "You need to get API token to use this plugin. Choose free plan and follow steps.",
        getApiToken: "Get API Token",
        checkToken: "Check Token",
        checking: "Checking...",
        tokenValid: "\u2705 Token is valid!",
        tokenInvalid: "\u274C Token is invalid. Please check your token.",
        tokenError: "\u274C Error checking token. Please try again later.",
        enterToken: "Enter API token to check",
        imagesHeading: "Images",
        saveImagesLocally: "Save images locally",
        saveImagesLocallyDesc: "Download and save images to local folder instead of using web URLs.",
        imagesFolder: "Images folder",
        imagesFolderDesc: "Folder where downloaded images will be saved.",
        imagesFolderPlaceholder: "Example: attachments/TMDB",
        savePosterImage: "Save poster images",
        savePosterImageDesc: "Download and save movie/series poster images.",
        saveCoverImage: "Save cover/backdrop images",
        saveCoverImageDesc: "Download and save movie/series cover/backdrop images.",
        saveLogoImage: "Save logo images",
        saveLogoImageDesc: "Download and save movie/series logo images.",
        imageFileNameFormat: "Image file name format",
        imageFileNameFormatDesc: "Enter the image file name format.",
        imageFileNameFormatPlaceholder: "Example: {{nameForFile}}_{{id}}_{{type}}",
        moviesHeading: "Movies",
        movieFileName: "Movie file name",
        movieFileNameDesc: "Enter the movie file name format.",
        movieFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
        movieFileLocation: "Movie file location",
        movieFileLocationDesc: "New movie notes will be placed here.",
        movieFileLocationPlaceholder: "Example: folder1/folder2",
        movieTemplateFile: "Movie template file",
        movieTemplateFileDesc: "Files will be available as templates.",
        movieTemplateFilePlaceholder: "Example: templates/template-file",
        exampleTemplate: "Example Template",
        seriesHeading: "TV series",
        seriesFileName: "TV series file name",
        seriesFileNameDesc: "Enter the TV series file name format.",
        seriesFileNamePlaceholder: "Example: {{nameForFile}} ({{year}})",
        seriesFileLocation: "TV series file location",
        seriesFileLocationDesc: "New TV series notes will be placed here.",
        seriesFileLocationPlaceholder: "Example: folder1/folder2",
        seriesTemplateFile: "TV series template file",
        seriesTemplateFileDesc: "Files will be available as templates.",
        seriesTemplateFilePlaceholder: "Example: templates/template-file",
        peopleHeading: "People Settings",
        actorsFileLocation: "Actors folder",
        actorsFileLocationDesc: "Folder where actor notes will be created",
        actorsFileLocationPlaceholder: "Example: People/Actors",
        directorsFileLocation: "Directors folder",
        directorsFileLocationDesc: "Folder where director notes will be created",
        directorsFileLocationPlaceholder: "Example: People/Directors",
        writersFileLocation: "Writers folder",
        writersFileLocationDesc: "Folder where writer notes will be created",
        writersFileLocationPlaceholder: "Example: People/Writers",
        producersFileLocation: "Producers folder",
        producersFileLocationDesc: "Folder where producer notes will be created",
        producersFileLocationPlaceholder: "Example: People/Producers",
        language: "Interface language",
        languageDesc: "Select the plugin interface language.",
        // Mobile settings
        mobileSettings: "Mobile Settings",
        mobileCoverHeightMultiplier: "Cover Height Multiplier",
        mobileCoverHeightMultiplierDesc: "Multiplier for cover height on mobile devices (default: 1.5)"
      },
      status: {
        selectStatus: "Select status:",
        willWatch: "Will watch",
        haveWatched: "Have watched",
        watching: "Watching",
        dropped: "Dropped",
        skip: "Skip",
        useDefault: "Use default status",
        defaultStatus: "Will watch"
      },
      ratings: {
        myRating: "My Rating",
        kinopoiskRating: "Kinopoisk Rating",
        year: "Year"
      }
    };
    translations = {
      ru,
      en
    };
    currentLanguage = "en";
  }
});

// Utils/utils.ts
function capitalizeFirstLetter(input) {
  if (!input || input.length === 0) {
    return input || "";
  }
  return input.charAt(0).toUpperCase() + input.slice(1);
}
function replaceIllegalFileNameCharactersInString(text) {
  if (!text) {
    return "";
  }
  return text.replace(/[\\/:*?"<>|]/g, "");
}
function getPlainValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = value[0];
      if (typeof firstValue === "string") {
        return firstValue.replace(/^"(.*)"$/, "$1");
      }
      return firstValue != null ? firstValue : "";
    }
    return value.filter((item) => item != null).map((item) => {
      if (typeof item === "string") {
        return item.replace(/^"(.*)"$/, "$1");
      }
      return String(item);
    }).join(", ");
  }
  if (typeof value === "number") {
    return value;
  }
  return String(value || "");
}
function getQuotedValueFromArray(value) {
  if (Array.isArray(value)) {
    if (value.length === 0) return "";
    if (value.length === 1) {
      const firstValue = String(value[0] || "");
      if (firstValue.startsWith("![[") || firstValue.startsWith("![](")) {
        if (!firstValue.startsWith('"') && !firstValue.endsWith('"')) {
          return `"${firstValue}"`;
        }
      }
      if (firstValue.startsWith('"') && firstValue.endsWith('"')) {
        const innerText = firstValue.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return firstValue;
    }
    return value.filter((item) => item != null).map((item) => {
      const itemStr = String(item);
      if (itemStr.startsWith("![[") || itemStr.startsWith("![](")) {
        if (!itemStr.startsWith('"') && !itemStr.endsWith('"')) {
          return `"${itemStr}"`;
        }
      }
      if (itemStr.startsWith('"') && itemStr.endsWith('"')) {
        const innerText = itemStr.slice(1, -1);
        const escapedInnerText = innerText.replace(/"/g, '\\"');
        return `"${escapedInnerText}"`;
      }
      return itemStr;
    }).join(", ");
  }
  const stringValue = String(value || "");
  if (stringValue.startsWith('"') && stringValue.endsWith('"')) {
    const innerText = stringValue.slice(1, -1);
    const escapedInnerText = innerText.replace(/"/g, '\\"');
    return `"${escapedInnerText}"`;
  }
  return stringValue;
}
function replaceVariableSyntax(movieShow, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  try {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = text.match(frontmatterRegex);
    if (match) {
      const [, frontmatter, body] = match;
      const processedFrontmatter = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const quotedValue = getQuotedValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              quotedValue
            );
          } catch (error) {
            console.error(
              `Error processing frontmatter variable ${key}:`,
              error
            );
            return result2;
          }
        },
        frontmatter
      );
      const processedBody = Object.entries(movieShow).reduce(
        (result2, [key, val = ""]) => {
          try {
            const plainValue = getPlainValueFromArray(val);
            return result2.replace(
              new RegExp(`{{${key}}}`, "ig"),
              String(plainValue)
            );
          } catch (error) {
            console.error(
              `Error processing body variable ${key}:`,
              error
            );
            return result2;
          }
        },
        body
      );
      const result = `---
${processedFrontmatter}
---
${processedBody}`;
      return result.replace(/{{\w+}}/gi, "").trim();
    } else {
      const entries = Object.entries(movieShow);
      return entries.reduce((result, [key, val = ""]) => {
        try {
          const plainValue = getPlainValueFromArray(val);
          return result.replace(
            new RegExp(`{{${key}}}`, "ig"),
            String(plainValue)
          );
        } catch (error) {
          console.error(
            `Error processing variable ${key}:`,
            error
          );
          return result;
        }
      }, text).replace(/{{\w+}}/gi, "").trim();
    }
  } catch (error) {
    console.error("Error in replaceVariableSyntax:", error);
    return text;
  }
}
async function makeFileName(app, movieShow, fileNameFormat, folderPath) {
  try {
    let baseName;
    if (fileNameFormat) {
      baseName = replaceVariableSyntax(movieShow, fileNameFormat);
    } else {
      baseName = `${movieShow.nameForFile || t("utils.unknownMovie")} (${movieShow.year || t("utils.unknownMovie")})`;
    }
    const cleanedBaseName = replaceIllegalFileNameCharactersInString(baseName);
    if (!cleanedBaseName.trim()) {
      return `${t("utils.unknownMovie")}.md`;
    }
    const fileName = cleanedBaseName + ".md";
    const { vault } = app;
    const fullPath = folderPath ? `${folderPath}/${fileName}` : fileName;
    const normalizedPath = (0, import_obsidian.normalizePath)(fullPath);
    if (!vault.getAbstractFileByPath(normalizedPath)) {
      return fileName;
    }
    let copyNumber = 1;
    let copyFileName;
    let copyFullPath;
    do {
      copyFileName = `${cleanedBaseName} (${t(
        "utils.copyPrefix"
      )}[${copyNumber}]).md`;
      copyFullPath = folderPath ? `${folderPath}/${copyFileName}` : copyFileName;
      copyNumber++;
    } while (vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(copyFullPath)));
    return copyFileName;
  } catch (error) {
    console.error("Error creating file name:", error);
    return `${t("utils.unknownMovie")}.md`;
  }
}
async function getTemplateContents(app, templatePath) {
  if (!templatePath || templatePath === "/") {
    return "";
  }
  try {
    const { metadataCache, vault } = app;
    const normalizedTemplatePath = (0, import_obsidian.normalizePath)(templatePath);
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    if (!templateFile) {
      console.warn(
        `${t("utils.templateNotFound")}: ${normalizedTemplatePath}`
      );
      return "";
    }
    return await vault.cachedRead(templateFile);
  } catch (error) {
    console.error(`Failed to read the template '${templatePath}':`, error);
    new import_obsidian.Notice(t("utils.templateReadError"));
    return "";
  }
}
var import_obsidian;
var init_utils = __esm({
  "Utils/utils.ts"() {
    import_obsidian = require("obsidian");
    init_i18n();
  }
});

// Utils/imageUtils.ts
var imageUtils_exports = {};
__export(imageUtils_exports, {
  downloadAndSaveImage: () => downloadAndSaveImage,
  processImages: () => processImages
});
function isValidImageUrl(url) {
  if (!url || url.trim() === "") return false;
  try {
    new URL(url);
    return url.startsWith("http://") || url.startsWith("https://");
  } catch (e) {
    return false;
  }
}
function getImageExtension(url, mimeType) {
  var _a;
  if (mimeType && MIME_TO_EXTENSION_MAP[mimeType]) {
    return MIME_TO_EXTENSION_MAP[mimeType];
  }
  const urlExtension = (_a = url.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  if (urlExtension && SUPPORTED_EXTENSIONS.includes(urlExtension)) {
    return urlExtension;
  }
  return "jpg";
}
function createImageFileName(movieShow, imageType, extension, imageFileNameFormat) {
  var _a;
  let fileNameFormat = imageFileNameFormat || "{{nameForFile}}";
  fileNameFormat = fileNameFormat.replace(/{{nameForFile}}/g, movieShow.nameForFile || "unknown").replace(/{{id}}/g, movieShow.id.toString() || "0").replace(/{{type}}/g, ((_a = movieShow.type) == null ? void 0 : _a[0]) || "unknown").replace(/{{year}}/g, movieShow.year.toString());
  const cleanedBaseName = replaceIllegalFileNameCharactersInString(fileNameFormat);
  return `${cleanedBaseName}_${imageType}.${extension}`;
}
function extractCleanPath(imagePath) {
  if (!imagePath || imagePath.trim() === "") return "";
  if (!imagePath.startsWith("http")) {
    return imagePath.split("/").pop() || imagePath;
  }
  return imagePath;
}
function isNetworkError(error) {
  if (!error || typeof error !== "object" || typeof error.message !== "string") {
    return false;
  }
  const networkErrors = [
    "ERR_CONNECTION_TIMED_OUT",
    "ERR_NETWORK_CHANGED",
    "ERR_INTERNET_DISCONNECTED",
    "ERR_NAME_NOT_RESOLVED",
    "ERR_CONNECTION_REFUSED",
    "ERR_CONNECTION_RESET",
    "ERR_BLOCKED_BY_CLIENT"
  ];
  return networkErrors.some(
    (errorCode) => error.message.includes(errorCode)
  );
}
function withTimeout(promise, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(
        new Error(tWithParams("images.timeout", { timeout: timeoutMs }))
      );
    }, timeoutMs);
  });
  return Promise.race([promise, timeoutPromise]);
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function downloadImage(url) {
  if (!isValidImageUrl(url)) {
    throw new Error(tWithParams("images.invalidUrl", { url }));
  }
  let lastError = new Error(
    tWithParams("images.downloadFailed", { url })
  );
  for (let attempt = 1; attempt <= DOWNLOAD_CONFIG.maxRetries; attempt++) {
    try {
      const downloadPromise = (0, import_obsidian4.requestUrl)({
        url,
        method: "GET"
      });
      const response = await withTimeout(
        downloadPromise,
        DOWNLOAD_CONFIG.timeout
      );
      if (response.status !== 200) {
        if (response.status === 404) {
          throw new Error(
            tWithParams("images.imageNotFound", { url })
          );
        } else if (response.status === 403) {
          throw new Error(
            tWithParams("images.accessForbidden", { url })
          );
        } else if (response.status >= 500) {
          throw new Error(
            tWithParams("images.serverError", {
              status: response.status,
              url
            })
          );
        } else {
          throw new Error(
            tWithParams("images.httpError", {
              status: response.status,
              url
            })
          );
        }
      }
      return {
        data: response.arrayBuffer,
        mimeType: response.headers["content-type"]
      };
    } catch (error) {
      lastError = error;
      console.warn(
        `Failed to download image (attempt ${attempt}/${DOWNLOAD_CONFIG.maxRetries}): ${url}`,
        error
      );
      if (attempt === DOWNLOAD_CONFIG.maxRetries || !isNetworkError(error)) {
        break;
      }
      if (attempt < DOWNLOAD_CONFIG.maxRetries) {
        await delay(DOWNLOAD_CONFIG.retryDelay);
      }
    }
  }
  console.error(
    `Failed to download image after ${DOWNLOAD_CONFIG.maxRetries} attempts: ${url}`,
    lastError
  );
  throw lastError;
}
async function saveImageToVault(app, imageData, folderPath, fileName) {
  const { vault } = app;
  const normalizedFolderPath = (0, import_obsidian4.normalizePath)(folderPath);
  if (!vault.getAbstractFileByPath(normalizedFolderPath)) {
    await vault.createFolder(normalizedFolderPath);
  }
  const fullPath = (0, import_obsidian4.normalizePath)(`${folderPath}/${fileName}`);
  let finalPath = fullPath;
  let counter = 1;
  while (vault.getAbstractFileByPath(finalPath)) {
    const pathParts = fullPath.split(".");
    const extension = pathParts.pop();
    const basePath = pathParts.join(".");
    finalPath = `${basePath}_${counter}.${extension}`;
    counter++;
  }
  await vault.createBinary(finalPath, imageData);
  return finalPath;
}
async function downloadAndSaveImage(app, url, movieShow, imageType, folderPath, imageFileNameFormat) {
  try {
    if (!isValidImageUrl(url)) {
      return url;
    }
    const { data, mimeType } = await downloadImage(url);
    const extension = getImageExtension(url, mimeType);
    const fileName = createImageFileName(movieShow, imageType, extension, imageFileNameFormat);
    const localPath = await saveImageToVault(
      app,
      data,
      folderPath,
      fileName
    );
    return localPath;
  } catch (error) {
    console.error(`Failed to download and save image: ${url}`, error);
    throw error;
  }
}
function createImageLink(imagePath) {
  if (!imagePath || imagePath.trim() === "") return [];
  if (!imagePath.startsWith("http")) {
    const fileName = imagePath.split("/").pop() || imagePath;
    return [`![[${fileName}]]`];
  }
  return [`![](${imagePath})`];
}
function countImagesToDownload(movieShow, settings) {
  let count = 0;
  if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0] && isValidImageUrl(movieShow.posterUrl[0])) {
    count++;
  }
  if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0] && isValidImageUrl(movieShow.coverUrl[0])) {
    count++;
  }
  if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0] && isValidImageUrl(movieShow.logoUrl[0])) {
    count++;
  }
  return count;
}
function getImageTypeDisplayName(imageType) {
  return t(`images.${imageType}`);
}
async function processImages(app, movieShow, settings, progressCallback) {
  if (!settings.saveImagesLocally) {
    return movieShow;
  }
  const updatedMovieShow = { ...movieShow };
  const totalImages = countImagesToDownload(movieShow, settings);
  let processedImages = 0;
  let successfulDownloads = 0;
  let failedDownloads = 0;
  if (totalImages === 0) {
    progressCallback == null ? void 0 : progressCallback(0, 0, t("images.noImagesToDownload"));
    return movieShow;
  }
  try {
    if (settings.savePosterImage && movieShow.posterUrl.length > 0 && movieShow.posterUrl[0]) {
      const posterUrl = movieShow.posterUrl[0];
      if (isValidImageUrl(posterUrl)) {
        const imageTypeName = getImageTypeDisplayName("poster");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            posterUrl,
            movieShow,
            "poster",
            settings.imagesFolder,
            settings.imageFileNameFormat
          );
          updatedMovieShow.posterMarkdown = createImageLink(localPath);
          updatedMovieShow.posterPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download poster image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.posterUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.poster")}`
            );
          }
          updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
          updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
        }
      } else {
        updatedMovieShow.posterMarkdown = createImageLink(posterUrl);
        updatedMovieShow.posterPath = [extractCleanPath(posterUrl)];
      }
    }
    if (settings.saveCoverImage && movieShow.coverUrl.length > 0 && movieShow.coverUrl[0]) {
      const coverUrl = movieShow.coverUrl[0];
      if (isValidImageUrl(coverUrl)) {
        const imageTypeName = getImageTypeDisplayName("cover");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            coverUrl,
            movieShow,
            "cover",
            settings.imagesFolder,
            settings.imageFileNameFormat
          );
          updatedMovieShow.coverMarkdown = createImageLink(localPath);
          updatedMovieShow.coverPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download cover image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.coverUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.cover")}`
            );
          }
          updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
          updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
        }
      } else {
        updatedMovieShow.coverMarkdown = createImageLink(coverUrl);
        updatedMovieShow.coverPath = [extractCleanPath(coverUrl)];
      }
    }
    if (settings.saveLogoImage && movieShow.logoUrl.length > 0 && movieShow.logoUrl[0]) {
      const logoUrl = movieShow.logoUrl[0];
      if (isValidImageUrl(logoUrl)) {
        const imageTypeName = getImageTypeDisplayName("logo");
        progressCallback == null ? void 0 : progressCallback(
          processedImages + 1,
          totalImages,
          `${t("images.downloading")} ${imageTypeName}...`
        );
        try {
          const localPath = await downloadAndSaveImage(
            app,
            logoUrl,
            movieShow,
            "logo",
            settings.imagesFolder,
            settings.imageFileNameFormat
          );
          updatedMovieShow.logoMarkdown = createImageLink(localPath);
          updatedMovieShow.logoPath = [extractCleanPath(localPath)];
          processedImages++;
          successfulDownloads++;
        } catch (error) {
          console.warn("Failed to download logo image:", error);
          processedImages++;
          failedDownloads++;
          if (isNetworkError(error)) {
            console.warn(t("images.logoUnavailable"));
          } else {
            console.warn(
              `${t("images.downloadError")} ${t("images.logo")}`
            );
          }
          updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
          updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
        }
      } else {
        updatedMovieShow.logoMarkdown = createImageLink(logoUrl);
        updatedMovieShow.logoPath = [extractCleanPath(logoUrl)];
      }
    }
    if (progressCallback) {
      if (failedDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          tWithParams("images.completedWithErrors", {
            successful: successfulDownloads,
            failed: failedDownloads
          })
        );
      } else if (successfulDownloads > 0) {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAllDownloaded")
        );
      } else {
        progressCallback(
          totalImages,
          totalImages,
          t("images.completedAlreadyLocal")
        );
      }
    }
    if (failedDownloads > 0) {
      if (successfulDownloads > 0) {
        new import_obsidian4.Notice(
          tWithParams("images.downloadedWithErrors", {
            successful: successfulDownloads,
            total: totalImages
          })
        );
      } else {
        new import_obsidian4.Notice(t("images.imagesUnavailable"));
      }
    }
  } catch (error) {
    console.error("Error processing images:", error);
    progressCallback == null ? void 0 : progressCallback(
      processedImages,
      totalImages,
      t("images.processingError")
    );
    new import_obsidian4.Notice(t("images.processingError"));
  }
  return updatedMovieShow;
}
var import_obsidian4, DOWNLOAD_CONFIG, SUPPORTED_EXTENSIONS, MIME_TO_EXTENSION_MAP;
var init_imageUtils = __esm({
  "Utils/imageUtils.ts"() {
    import_obsidian4 = require("obsidian");
    init_utils();
    init_i18n();
    DOWNLOAD_CONFIG = {
      timeout: 1e4,
      // 10 seconds timeout
      maxRetries: 2,
      // maximum 2 attempts
      retryDelay: 1e3
      // delay between attempts in ms
    };
    SUPPORTED_EXTENSIONS = [
      "jpg",
      "jpeg",
      "png",
      "gif",
      "webp",
      "svg",
      "bmp"
    ];
    MIME_TO_EXTENSION_MAP = {
      "image/jpeg": "jpg",
      "image/jpg": "jpg",
      "image/png": "png",
      "image/gif": "gif",
      "image/webp": "webp",
      "image/svg+xml": "svg",
      "image/bmp": "bmp"
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianTMDBPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// Views/search_modal.ts
var import_obsidian3 = require("obsidian");

// APIProvider/provider.ts
var import_obsidian2 = require("obsidian");

// APIProvider/ErrorHandler.ts
init_i18n();
var NETWORK_ERROR_PATTERNS = [
  "net::",
  "NetworkError",
  "Failed to fetch",
  "ENOTFOUND",
  "ECONNREFUSED",
  "ETIMEDOUT"
];
var ErrorHandler = class {
  /**
   * Returns localized error message for HTTP status code
   */
  getHttpStatusMessage(status) {
    const statusMessages = {
      400: t("errorHandler.badRequest"),
      401: t("errorHandler.unauthorized"),
      403: t("errorHandler.forbidden"),
      404: t("errorHandler.notFound"),
      429: t("errorHandler.tooManyRequests"),
      500: t("errorHandler.internalServerError"),
      502: t("errorHandler.badGateway"),
      503: t("errorHandler.serviceUnavailable"),
      504: t("errorHandler.gatewayTimeout")
    };
    return statusMessages[status] || "";
  }
  /**
   * Processes API errors and creates user-friendly error messages
   */
  handleApiError(error) {
    const errorDetails = this.extractErrorDetails(error);
    if (errorDetails.isNetworkError) {
      return new Error(t("errorHandler.networkError"));
    }
    const knownMessage = this.getHttpStatusMessage(errorDetails.status);
    if (knownMessage) {
      return new Error(knownMessage);
    }
    if (errorDetails.status > 0) {
      return new Error(
        tWithParams("errorHandler.unknownStatusError", {
          status: errorDetails.status.toString()
        })
      );
    }
    return new Error(t("errorHandler.unexpectedError"));
  }
  /**
   * Extracts error details from various error formats
   */
  extractErrorDetails(error) {
    const details = {
      status: 0,
      message: "",
      isNetworkError: false,
      originalError: error
    };
    if (this.isNetworkError(error)) {
      details.isNetworkError = true;
      return details;
    }
    details.status = this.extractStatusCode(error);
    return details;
  }
  isNetworkError(error) {
    if (!(error instanceof Error)) {
      return false;
    }
    return NETWORK_ERROR_PATTERNS.some(
      (pattern) => error.message.includes(pattern)
    );
  }
  /**
   * Extracts HTTP status code from error object
   */
  extractStatusCode(error) {
    if (!error || typeof error !== "object") {
      return 0;
    }
    if ("status" in error && typeof error.status === "number") {
      return error.status;
    }
    if ("response" in error && error.response && typeof error.response === "object" && "status" in error.response && typeof error.response.status === "number") {
      return error.response.status;
    }
    if ("statusCode" in error && typeof error.statusCode === "number") {
      return error.statusCode;
    }
    return 0;
  }
  logError(context, error) {
    console.error(`[${context}] Error:`, error);
  }
};

// APIProvider/DataFormatter.ts
init_utils();
var MAX_ARRAY_ITEMS = 50;
var MAX_FACTS_COUNT = 5;
var TMDB_CONFIG = {
  IMAGE_BASE_URL: "https://image.tmdb.org/t/p/",
  SIZES: {
    POSTER_ORIGINAL: "original",
    POSTER_W500: "w500",
    POSTER_W185: "w185",
    BACKDROP_ORIGINAL: "original",
    BACKDROP_W1280: "w1280",
    PROFILE_W185: "w185"
  }
};
var AGE_RATING_MAP = {
  MOVIE: {
    "G": 0,
    "PG": 6,
    "PG-13": 13,
    "R": 17,
    "NC-17": 18
  },
  TV: {
    "TV-Y": 0,
    "TV-Y7": 7,
    "TV-G": 0,
    "TV-PG": 10,
    "TV-14": 14,
    "TV-MA": 17
  }
};
var PROFESSION_MAP = {
  "Director": { enProfession: "director", profession: "\u0440\u0435\u0436\u0438\u0441\u0441\u0435\u0440" },
  "Writer": { enProfession: "writer", profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442" },
  "Screenplay": { enProfession: "writer", profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442" },
  "Producer": { enProfession: "producer", profession: "\u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440" },
  "Executive Producer": { enProfession: "producer", profession: "\u043F\u0440\u043E\u0434\u044E\u0441\u0435\u0440" }
};
var TYPE_TRANSLATIONS = {
  "animated-series": "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u043E\u043D\u043D\u044B\u0439 \u0441\u0435\u0440\u0438\u0430\u043B",
  anime: "\u0410\u043D\u0438\u043C\u0435",
  cartoon: "\u041C\u0443\u043B\u044C\u0442\u0444\u0438\u043B\u044C\u043C",
  movie: "\u0424\u0438\u043B\u044C\u043C",
  "tv-series": "\u0421\u0435\u0440\u0438\u0430\u043B"
};
var HTML_ENTITIES = {
  "&laquo;": "\xAB",
  "&raquo;": "\xBB",
  "&ldquo;": '"',
  "&rdquo;": '"',
  "&lsquo;": "'",
  "&rsquo;": "'",
  "&quot;": '"',
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&nbsp;": " ",
  "&ndash;": "\u2013",
  "&mdash;": "\u2014",
  "&hellip;": "\u2026"
};
var DataFormatter = class {
  /**
   * Set settings for path support
   */
  setSettings(settings) {
    this.settings = settings;
  }
  /**
   * Build TMDB image URL
   */
  buildImageUrl(path, size) {
    return `${TMDB_CONFIG.IMAGE_BASE_URL}${size}${path}`;
  }
  /**
   * Extract best image by language priority (ru -> en -> any)
   */
  extractBestImage(images, type) {
    if (!images || images.length === 0) {
      return void 0;
    }
    const ruImage = images.find((img) => img.iso_639_1 === "ru");
    if (ruImage) {
      return {
        url: this.buildImageUrl(ruImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
        previewUrl: this.buildImageUrl(ruImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
      };
    }
    const enImage = images.find((img) => img.iso_639_1 === "en");
    if (enImage) {
      return {
        url: this.buildImageUrl(enImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
        previewUrl: this.buildImageUrl(enImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
      };
    }
    const anyImage = images[0];
    return {
      url: this.buildImageUrl(anyImage.file_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
      previewUrl: this.buildImageUrl(anyImage.file_path, TMDB_CONFIG.SIZES.POSTER_W500)
    };
  }
  /**
   * Convert TMDB credits to persons format
   */
  convertCreditsToPersons(credits) {
    const persons = [];
    (credits.cast || []).slice(0, 20).forEach((person) => {
      persons.push({
        id: person.id,
        name: person.name,
        enName: person.original_name || person.name,
        enProfession: "actor",
        profession: "\u0430\u043A\u0442\u0435\u0440",
        photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
      });
    });
    (credits.crew || []).forEach((person) => {
      const mapping = PROFESSION_MAP[person.job];
      if (!mapping && person.department === "Writing") {
        persons.push({
          id: person.id,
          name: person.name,
          enName: person.original_name || person.name,
          enProfession: "writer",
          profession: "\u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0441\u0442",
          photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
        });
      } else if (mapping) {
        persons.push({
          id: person.id,
          name: person.name,
          enName: person.original_name || person.name,
          enProfession: mapping.enProfession,
          profession: mapping.profession,
          photo: person.profile_path ? this.buildImageUrl(person.profile_path, TMDB_CONFIG.SIZES.PROFILE_W185) : void 0
        });
      }
    });
    return persons;
  }
  /**
   * Extract age rating from TMDB release dates
   */
  extractAgeRating(releaseDates) {
    var _a, _b;
    if (!(releaseDates == null ? void 0 : releaseDates.results)) return 0;
    const usRelease = releaseDates.results.find((r) => r.iso_3166_1 === "US");
    if ((_b = (_a = usRelease == null ? void 0 : usRelease.release_dates) == null ? void 0 : _a[0]) == null ? void 0 : _b.certification) {
      const cert = usRelease.release_dates[0].certification;
      return AGE_RATING_MAP.MOVIE[cert] || 0;
    }
    return 0;
  }
  /**
   * Extract MPAA rating string
   */
  extractMpaaRating(releaseDates) {
    var _a, _b;
    if (!(releaseDates == null ? void 0 : releaseDates.results)) return "";
    const usRelease = releaseDates.results.find((r) => r.iso_3166_1 === "US");
    return ((_b = (_a = usRelease == null ? void 0 : usRelease.release_dates) == null ? void 0 : _a[0]) == null ? void 0 : _b.certification) || "";
  }
  /**
   * Extract age rating for TV shows
   */
  extractTVAgeRating(contentRatings) {
    if (!(contentRatings == null ? void 0 : contentRatings.results)) return 0;
    const usRating = contentRatings.results.find((r) => r.iso_3166_1 === "US");
    if (usRating == null ? void 0 : usRating.rating) {
      return AGE_RATING_MAP.TV[usRating.rating] || 0;
    }
    return 0;
  }
  /**
   * Convert TMDB movie data to TMDBFullInfo format
   */
  convertMovieToTMDBFormat(details, credits, images) {
    var _a, _b, _c, _d, _e;
    const year = details.release_date ? parseInt(details.release_date.substring(0, 4)) : 0;
    const poster = ((_a = images == null ? void 0 : images.posters) == null ? void 0 : _a.length) > 0 ? this.extractBestImage(images.posters, "poster") : details.poster_path ? {
      url: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
      previewUrl: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_W500)
    } : void 0;
    const backdrop = ((_b = images == null ? void 0 : images.backdrops) == null ? void 0 : _b.length) > 0 ? this.extractBestImage(images.backdrops, "backdrop") : details.backdrop_path ? {
      url: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_ORIGINAL),
      previewUrl: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_W1280)
    } : void 0;
    const logo = ((_c = images == null ? void 0 : images.logos) == null ? void 0 : _c.length) > 0 ? this.extractBestImage(images.logos, "logo") : void 0;
    return {
      id: details.id,
      name: details.title || "",
      alternativeName: details.original_title || "",
      enName: details.original_language === "en" ? details.original_title : details.title,
      type: "movie",
      year,
      description: details.overview || "",
      shortDescription: details.tagline || "",
      poster,
      backdrop,
      logo,
      genres: (details.genres || []).map((g) => ({ name: g.name })),
      countries: (details.production_countries || []).map((c) => ({ name: c.name })),
      persons: this.convertCreditsToPersons(credits),
      movieLength: details.runtime || 0,
      isSeries: false,
      TMDBLink: details.homepage,
      rating: {
        tmdb: details.vote_average || 0,
        imdb: details.vote_average || 0
      },
      votes: {
        tmdb: details.vote_count || 0,
        imdb: details.vote_count || 0
      },
      externalId: {
        imdb: details.imdb_id,
        tmdb: details.id
      },
      slogan: details.tagline,
      budget: details.budget ? {
        value: details.budget,
        currency: "USD"
      } : void 0,
      fees: details.revenue ? {
        world: {
          value: details.revenue,
          currency: "USD"
        }
      } : void 0,
      premiere: {
        world: details.release_date
      },
      ageRating: this.extractAgeRating(details.release_dates),
      ratingMpaa: this.extractMpaaRating(details.release_dates),
      productionCompanies: (details.production_companies || []).map((c) => ({
        name: c.name
      })),
      networks: details.networks ? {
        items: details.networks.map((n) => ({ name: n.name }))
      } : void 0,
      names: ((_e = (_d = details.alternative_titles) == null ? void 0 : _d.titles) == null ? void 0 : _e.map((t2) => ({
        name: t2.title,
        type: t2.type
      }))) || []
    };
  }
  /**
   * Convert TMDB TV show data to TMDBFullInfo format
   */
  convertTVShowToTMDBFormat(details, credits, images) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const year = details.first_air_date ? parseInt(details.first_air_date.substring(0, 4)) : 0;
    const poster = ((_a = images == null ? void 0 : images.posters) == null ? void 0 : _a.length) > 0 ? this.extractBestImage(images.posters, "poster") : details.poster_path ? {
      url: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_ORIGINAL),
      previewUrl: this.buildImageUrl(details.poster_path, TMDB_CONFIG.SIZES.POSTER_W500)
    } : void 0;
    const backdrop = ((_b = images == null ? void 0 : images.backdrops) == null ? void 0 : _b.length) > 0 ? this.extractBestImage(images.backdrops, "backdrop") : details.backdrop_path ? {
      url: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_ORIGINAL),
      previewUrl: this.buildImageUrl(details.backdrop_path, TMDB_CONFIG.SIZES.BACKDROP_W1280)
    } : void 0;
    const logo = ((_c = images == null ? void 0 : images.logos) == null ? void 0 : _c.length) > 0 ? this.extractBestImage(images.logos, "logo") : void 0;
    return {
      id: details.id,
      name: details.name || "",
      alternativeName: details.original_name || "",
      enName: details.original_language === "en" ? details.original_name : details.name,
      type: "tv-series",
      year,
      description: details.overview || "",
      shortDescription: details.tagline || "",
      poster,
      backdrop,
      logo,
      genres: (details.genres || []).map((g) => ({ name: g.name })),
      countries: (details.production_countries || []).map((c) => ({ name: c.name })),
      persons: this.convertCreditsToPersons(credits),
      isSeries: true,
      TMDBLink: details.homepage,
      seriesLength: ((_d = details.episode_run_time) == null ? void 0 : _d[0]) || 0,
      totalSeriesLength: (details.number_of_episodes || 0) * (((_e = details.episode_run_time) == null ? void 0 : _e[0]) || 0),
      status: details.status,
      seasonsInfo: (details.seasons || []).filter((s) => s.season_number > 0).map((s) => ({
        number: s.season_number,
        episodesCount: s.episode_count
      })),
      rating: {
        tmdb: details.vote_average || 0,
        imdb: details.vote_average || 0
      },
      votes: {
        tmdb: details.vote_count || 0,
        imdb: details.vote_count || 0
      },
      externalId: {
        imdb: (_f = details.external_ids) == null ? void 0 : _f.imdb_id,
        tmdb: details.id
      },
      premiere: {
        world: details.first_air_date
      },
      releaseYears: [{
        start: year,
        end: details.last_air_date ? parseInt(details.last_air_date.substring(0, 4)) : void 0
      }],
      ageRating: this.extractTVAgeRating(details.content_ratings),
      productionCompanies: (details.production_companies || []).map((c) => ({
        name: c.name
      })),
      networks: {
        items: (details.networks || []).map((n) => ({ name: n.name }))
      },
      names: ((_h = (_g = details.alternative_titles) == null ? void 0 : _g.results) == null ? void 0 : _h.map((t2) => ({
        name: t2.title,
        type: t2.type
      }))) || []
    };
  }
  /**
   * Transforms API data into MovieShow format
   */
  createMovieShowFrom(fullInfo, userRating) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X;
    const seasonsData = this.calculateSeasonsData(fullInfo.seasonsInfo);
    const people = this.extractPeople(fullInfo.persons || []);
    const companies = this.extractCompanies(fullInfo);
    const facts = this.processFacts(fullInfo.facts || []);
    const names = this.processNames(fullInfo);
    const firstReleaseYear = (_a = fullInfo.releaseYears) == null ? void 0 : _a[0];
    const item = {
      // Basic information
      id: fullInfo.id,
      name: this.formatArray([fullInfo.name], "short" /* SHORT_VALUE */),
      alternativeName: this.formatArray(
        [fullInfo.alternativeName || ""],
        "short" /* SHORT_VALUE */
      ),
      year: fullInfo.year,
      description: this.formatArray(
        [fullInfo.description || ""],
        "long" /* LONG_TEXT */
      ),
      shortDescription: this.formatArray(
        [fullInfo.shortDescription || ""],
        "long" /* LONG_TEXT */
      ),
      // Additional properties for filenames
      nameForFile: this.cleanTextForMetadata(fullInfo.name),
      alternativeNameForFile: this.cleanTextForMetadata(
        fullInfo.alternativeName || ""
      ),
      enNameForFile: this.cleanTextForMetadata(fullInfo.enName || ""),
      // TMDB Link
      TMDBLink: this.formatArray(
        [`https://www.themoviedb.org/${fullInfo.type === "tv-series" ? "tv" : "movie"}/${fullInfo.id}`],
        "url" /* URL */
      ),
      // Images
      posterUrl: this.formatArray(
        [((_b = fullInfo.poster) == null ? void 0 : _b.url) || ""],
        "url" /* URL */
      ),
      coverUrl: this.formatArray(
        [((_c = fullInfo.backdrop) == null ? void 0 : _c.url) || ""],
        "url" /* URL */
      ),
      logoUrl: this.formatArray(
        [((_d = fullInfo.logo) == null ? void 0 : _d.url) || ""],
        "url" /* URL */
      ),
      // Ready-to-use image links for Obsidian
      posterMarkdown: this.createImageLink(((_e = fullInfo.poster) == null ? void 0 : _e.url) || ""),
      coverMarkdown: this.createImageLink(((_f = fullInfo.backdrop) == null ? void 0 : _f.url) || ""),
      logoMarkdown: this.createImageLink(((_g = fullInfo.logo) == null ? void 0 : _g.url) || ""),
      // Clean image paths for template sizing
      posterPath: [],
      coverPath: [],
      logoPath: [],
      coverPathMobile: [],
      // Classification
      genres: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "short" /* SHORT_VALUE */
      ),
      genresLinks: this.formatArray(
        fullInfo.genres.map((g) => capitalizeFirstLetter(g.name)),
        "link" /* LINK */
      ),
      countries: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "short" /* SHORT_VALUE */
      ),
      countriesLinks: this.formatArray(
        fullInfo.countries.map((c) => c.name),
        "link" /* LINK */
      ),
      type: this.formatArray(
        [this.translateType(fullInfo.type || "")],
        "short" /* SHORT_VALUE */
      ),
      subType: this.formatArray(
        [fullInfo.subType || ""],
        "short" /* SHORT_VALUE */
      ),
      // People
      director: this.formatArray(people.directors, "short" /* SHORT_VALUE */),
      directorsLinks: this.formatArray(people.directors, "link" /* LINK */),
      directorsLinksWithPath: this.formatArray(
        people.directors,
        "link_with_path" /* LINK_WITH_PATH */,
        (_h = this.settings) == null ? void 0 : _h.directorsPath
      ),
      directorsIdsWithPath: this.formatArray(
        people.directors,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_i = this.settings) == null ? void 0 : _i.directorsPath
      ),
      actors: this.formatArray(people.actors, "short" /* SHORT_VALUE */),
      actorsLinks: this.formatArray(people.actors, "link" /* LINK */),
      actorsLinksWithPath: this.formatArray(
        people.actors,
        "link_with_path" /* LINK_WITH_PATH */,
        (_j = this.settings) == null ? void 0 : _j.actorsPath
      ),
      actorsIdsWithPath: this.formatArray(
        people.actors,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_k = this.settings) == null ? void 0 : _k.actorsPath
      ),
      writers: this.formatArray(people.writers, "short" /* SHORT_VALUE */),
      writersLinks: this.formatArray(people.writers, "link" /* LINK */),
      writersLinksWithPath: this.formatArray(
        people.writers,
        "link_with_path" /* LINK_WITH_PATH */,
        (_l = this.settings) == null ? void 0 : _l.writersPath
      ),
      writersIdsWithPath: this.formatArray(
        people.writers,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_m = this.settings) == null ? void 0 : _m.writersPath
      ),
      producers: this.formatArray(people.producers, "short" /* SHORT_VALUE */),
      producersLinks: this.formatArray(people.producers, "link" /* LINK */),
      producersLinksWithPath: this.formatArray(
        people.producers,
        "link_with_path" /* LINK_WITH_PATH */,
        (_n = this.settings) == null ? void 0 : _n.producersPath
      ),
      producersIdsWithPath: this.formatArray(
        people.producers,
        "link_id_with_path" /* LINK_ID_WITH_PATH */,
        (_o = this.settings) == null ? void 0 : _o.producersPath
      ),
      // Technical specifications
      movieLength: fullInfo.movieLength || 0,
      isSeries: fullInfo.isSeries,
      seriesLength: fullInfo.seriesLength || 0,
      totalSeriesLength: fullInfo.totalSeriesLength || 0,
      isComplete: fullInfo.isSeries ? fullInfo.status === "Ended" || fullInfo.status === "Canceled" ? "\u0417\u0430\u0432\u0435\u0440\u0448\u0435\u043D" : "\u0412 \u044D\u0444\u0438\u0440\u0435" : "\u0412\u044B\u0448\u0435\u043B",
      seasonsCount: seasonsData.count,
      seriesInSeasonCount: seasonsData.averageEpisodesPerSeason,
      // Ratings and votes
      ratingTmdb: ((_p = fullInfo.rating) == null ? void 0 : _p.tmdb) ? Number((_r = (_q = fullInfo.rating) == null ? void 0 : _q.tmdb) == null ? void 0 : _r.toFixed(1)) : 0,
      ratingImdb: ((_s = fullInfo.rating) == null ? void 0 : _s.imdb) ? Number((_u = (_t = fullInfo.rating) == null ? void 0 : _t.imdb) == null ? void 0 : _u.toFixed(1)) : 0,
      ratingFilmCritics: ((_v = fullInfo.rating) == null ? void 0 : _v.filmCritics) || 0,
      ratingRussianFilmCritics: ((_w = fullInfo.rating) == null ? void 0 : _w.russianFilmCritics) || 0,
      votesTmdb: ((_x = fullInfo.votes) == null ? void 0 : _x.tmdb) || 0,
      votesImdb: ((_y = fullInfo.votes) == null ? void 0 : _y.imdb) || 0,
      votesFilmCritics: ((_z = fullInfo.votes) == null ? void 0 : _z.filmCritics) || 0,
      votesRussianFilmCritics: ((_A = fullInfo.votes) == null ? void 0 : _A.russianFilmCritics) || 0,
      // External IDs and links
      TMDBUrl: this.formatArray(
        [`https://www.themoviedb.org/${fullInfo.type === "tv-series" ? "tv" : "movie"}/${fullInfo.id}`],
        "url" /* URL */
      ),
      imdbId: this.formatArray(
        [((_B = fullInfo.externalId) == null ? void 0 : _B.imdb) || ""],
        "short" /* SHORT_VALUE */
      ),
      tmdbId: ((_C = fullInfo.externalId) == null ? void 0 : _C.tmdb) || 0,
      // Additional information
      slogan: this.formatArray(
        [fullInfo.slogan || ""],
        "long" /* LONG_TEXT */
      ),
      ageRating: fullInfo.ageRating || 0,
      ratingMpaa: this.formatArray(
        [fullInfo.ratingMpaa || ""],
        "short" /* SHORT_VALUE */
      ),
      // Status - initially empty, will be set separately
      status: this.formatArray([""], "short" /* SHORT_VALUE */),
      // Financial data
      budgetValue: ((_D = fullInfo.budget) == null ? void 0 : _D.value) || 0,
      budgetCurrency: this.formatArray(
        [((_E = fullInfo.budget) == null ? void 0 : _E.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesWorldValue: ((_G = (_F = fullInfo.fees) == null ? void 0 : _F.world) == null ? void 0 : _G.value) || 0,
      feesWorldCurrency: this.formatArray(
        [((_I = (_H = fullInfo.fees) == null ? void 0 : _H.world) == null ? void 0 : _I.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesRussiaValue: ((_K = (_J = fullInfo.fees) == null ? void 0 : _J.russia) == null ? void 0 : _K.value) || 0,
      feesRussiaCurrency: this.formatArray(
        [((_M = (_L = fullInfo.fees) == null ? void 0 : _L.russia) == null ? void 0 : _M.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      feesUsaValue: ((_O = (_N = fullInfo.fees) == null ? void 0 : _N.usa) == null ? void 0 : _O.value) || 0,
      feesUsaCurrency: this.formatArray(
        [((_Q = (_P = fullInfo.fees) == null ? void 0 : _P.usa) == null ? void 0 : _Q.currency) || ""],
        "short" /* SHORT_VALUE */
      ),
      // Premiere dates
      premiereWorld: this.formatArray(
        [this.formatDate((_R = fullInfo.premiere) == null ? void 0 : _R.world)],
        "short" /* SHORT_VALUE */
      ),
      premiereRussia: this.formatArray(
        [this.formatDate((_S = fullInfo.premiere) == null ? void 0 : _S.russia)],
        "short" /* SHORT_VALUE */
      ),
      premiereDigital: this.formatArray(
        [this.formatDate((_T = fullInfo.premiere) == null ? void 0 : _T.digital)],
        "short" /* SHORT_VALUE */
      ),
      premiereCinema: this.formatArray(
        [this.formatDate((_U = fullInfo.premiere) == null ? void 0 : _U.cinema)],
        "short" /* SHORT_VALUE */
      ),
      // Release years
      releaseYearsStart: (firstReleaseYear == null ? void 0 : firstReleaseYear.start) || 0,
      releaseYearsEnd: (firstReleaseYear == null ? void 0 : firstReleaseYear.end) || 0,
      // Top ratings
      top10: fullInfo.top10 || 0,
      top250: fullInfo.top250 || 0,
      // Facts
      facts: this.formatArray(facts, "long" /* LONG_TEXT */),
      // Alternative names
      allNamesString: this.formatArray(
        names.allNames,
        "short" /* SHORT_VALUE */
      ),
      enName: this.formatArray(
        [fullInfo.enName || ""],
        "short" /* SHORT_VALUE */
      ),
      // Networks and companies
      networks: this.formatArray(
        companies.networks,
        "short" /* SHORT_VALUE */
      ),
      networksLinks: this.formatArray(
        companies.networks,
        "link" /* LINK */
      ),
      productionCompanies: this.formatArray(
        companies.productionCompanies,
        "short" /* SHORT_VALUE */
      ),
      productionCompaniesLinks: this.formatArray(
        companies.productionCompanies,
        "link" /* LINK */
      ),
      // Distributors
      distributor: this.formatArray(
        [((_V = fullInfo.distributors) == null ? void 0 : _V.distributor) || ""],
        "short" /* SHORT_VALUE */
      ),
      distributorRelease: this.formatArray(
        [
          this.formatDate(
            (_W = fullInfo.distributors) == null ? void 0 : _W.distributorRelease
          ) || ((_X = fullInfo.distributors) == null ? void 0 : _X.distributorRelease) || ""
        ],
        "short" /* SHORT_VALUE */
      ),
      // Related movies/series
      sequelsAndPrequels: this.formatArray(
        companies.sequelsAndPrequels,
        "short" /* SHORT_VALUE */
      ),
      sequelsAndPrequelsLinks: this.formatArray(
        companies.sequelsAndPrequels,
        "link" /* LINK */
      )
    };
    if (userRating !== void 0) {
      item.userRating = userRating;
    }
    return item;
  }
  /**
   * Universal array formatting based on type
   */
  formatArray(items, formatType, folderPath, maxItems = MAX_ARRAY_ITEMS) {
    if (formatType === "link_id_with_path" /* LINK_ID_WITH_PATH */) {
      const personItems = items;
      return personItems.filter((item) => item.name && item.name.trim() !== "").slice(0, maxItems).map((item) => {
        const cleanName = this.cleanTextForMetadata(item.name);
        if (folderPath && folderPath.trim() !== "" && item.id) {
          return `"[[${folderPath}/${item.id}|${cleanName}]]"`;
        } else if (item.id) {
          return `"[[${item.id}|${cleanName}]]"`;
        }
        return `"[[${cleanName}]]"`;
      });
    }
    const stringItems = items.map(
      (item) => typeof item === "object" && item.name ? item.name : item
    );
    const filteredItems = stringItems.filter((item) => typeof item === "string" && item.trim() !== "").slice(0, maxItems);
    switch (formatType) {
      case "short" /* SHORT_VALUE */:
        return filteredItems.map(
          (item) => this.cleanTextForMetadata(item)
        );
      case "long" /* LONG_TEXT */:
        return filteredItems.map((item) => {
          const cleanedItem = item.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
          return `"${cleanedItem}"`;
        });
      case "url" /* URL */:
        return filteredItems.map((item) => item.trim());
      case "link" /* LINK */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          return `"[[${cleanName}]]"`;
        });
      case "link_with_path" /* LINK_WITH_PATH */:
        return filteredItems.map((item) => {
          const cleanName = this.cleanTextForMetadata(item);
          if (folderPath && folderPath.trim() !== "") {
            return `"[[${folderPath}/${cleanName}]]"`;
          }
          return `"[[${cleanName}]]"`;
        });
      default:
        return filteredItems;
    }
  }
  /**
   * Calculates seasons data from seasons info
   */
  calculateSeasonsData(seasonsInfo) {
    if (!seasonsInfo || seasonsInfo.length === 0) {
      return { count: 0, averageEpisodesPerSeason: 0 };
    }
    const totalEpisodes = seasonsInfo.reduce(
      (total, season) => total + season.episodesCount,
      0
    );
    const averageEpisodes = Math.ceil(totalEpisodes / seasonsInfo.length);
    return {
      count: seasonsInfo.length,
      averageEpisodesPerSeason: averageEpisodes
    };
  }
  /**
   * Extracts people by profession from persons array
   */
  extractPeople(persons) {
    const result = {
      directors: [],
      actors: [],
      writers: [],
      producers: []
    };
    for (const person of persons) {
      if (!person.name || !person.enProfession) continue;
      const personData = { name: person.name, id: person.id };
      switch (person.enProfession) {
        case "director":
          result.directors.push(personData);
          break;
        case "actor":
          result.actors.push(personData);
          break;
        case "writer":
          result.writers.push(personData);
          break;
        case "producer":
          result.producers.push(personData);
          break;
      }
    }
    return result;
  }
  /**
   * Extracts companies and related movies from API response
   */
  extractCompanies(fullInfo) {
    var _a, _b, _c, _d;
    const networks = ((_b = (_a = fullInfo.networks) == null ? void 0 : _a.items) == null ? void 0 : _b.map((network) => network.name).filter((name) => name && name.trim() !== "")) || [];
    const productionCompanies = ((_c = fullInfo.productionCompanies) == null ? void 0 : _c.map((company) => company.name).filter((name) => name && name.trim() !== "")) || [];
    const sequelsAndPrequels = ((_d = fullInfo.sequelsAndPrequels) == null ? void 0 : _d.map((movie) => movie.name).filter((name) => name && name.trim() !== "")) || [];
    return { networks, productionCompanies, sequelsAndPrequels };
  }
  /**
   * Processes facts by removing spoilers and HTML tags
   */
  processFacts(facts) {
    return facts.filter(
      (fact) => !fact.spoiler && fact.value && fact.value.trim() !== ""
    ).slice(0, MAX_FACTS_COUNT).map((fact) => this.stripHtmlTags(fact.value));
  }
  processNames(fullInfo) {
    var _a;
    const allNames = ((_a = fullInfo.names) == null ? void 0 : _a.map((nameObj) => nameObj.name).filter((name) => name && name.trim() !== "")) || [];
    return { allNames };
  }
  /**
   * Formats date to Obsidian format (YYYY-MM-DD)
   */
  formatDate(dateString) {
    if (!dateString) return "";
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime()) || date.getFullYear() < 1800 || date.getFullYear() > 2100) {
        return "";
      }
      return date.toISOString().split("T")[0];
    } catch (e) {
      return "";
    }
  }
  /**
   * Cleans text from characters that might break metadata
   */
  cleanTextForMetadata(text) {
    if (!text) return "";
    return text.replace(/:/g, "").trim();
  }
  /**
   * Creates image link for Obsidian format
   */
  createImageLink(imagePath) {
    if (!imagePath || imagePath.trim() === "") return [];
    if (!imagePath.startsWith("http")) {
      return [`![[${imagePath}]]`];
    }
    return [`![](${imagePath})`];
  }
  translateType(type) {
    return TYPE_TRANSLATIONS[type] || type;
  }
  /**
   * Removes HTML tags and decodes HTML entities
   */
  stripHtmlTags(text) {
    let cleanText = text.replace(/<[^>]*>/g, "");
    for (const [entity, char] of Object.entries(HTML_ENTITIES)) {
      cleanText = cleanText.replace(new RegExp(entity, "g"), char);
    }
    cleanText = cleanText.replace(/&#?\w+;/g, "");
    return cleanText.trim();
  }
};

// APIProvider/ApiValidator.ts
init_i18n();
var MIN_QUERY_LENGTH = 1;
var MAX_QUERY_LENGTH = 200;
var MIN_TOKEN_LENGTH = 20;
var MAX_TOKEN_LENGTH = 500;
var MIN_MOVIE_ID = 1;
var MAX_MOVIE_ID = 99999999;
var ApiValidator = class {
  /**
   * Validates API token format and length for TMDB
   */
  isValidToken(token) {
    if (typeof token !== "string") {
      return false;
    }
    const trimmedToken = token.trim();
    if (!trimmedToken) {
      return false;
    }
    if (trimmedToken.length < MIN_TOKEN_LENGTH || trimmedToken.length > MAX_TOKEN_LENGTH) {
      return false;
    }
    const tokenPattern = /^[A-Za-z0-9\-_\.]+$/;
    if (!tokenPattern.test(trimmedToken)) {
      return false;
    }
    return true;
  }
  /**
   * Validates search query for safety and length
   */
  isValidSearchQuery(query) {
    if (typeof query !== "string") {
      return false;
    }
    const trimmedQuery = query.trim();
    if (!trimmedQuery) {
      return false;
    }
    if (trimmedQuery.length < MIN_QUERY_LENGTH || trimmedQuery.length > MAX_QUERY_LENGTH) {
      return false;
    }
    const suspiciousPatterns = [
      /<script/i,
      /javascript:/i,
      /on\w+=/i,
      /<%/,
      /%>/
    ];
    if (suspiciousPatterns.some((pattern) => pattern.test(trimmedQuery))) {
      return false;
    }
    return true;
  }
  /**
   * Validates movie ID range and type
   */
  isValidMovieId(id) {
    if (typeof id !== "number") {
      return false;
    }
    if (!Number.isFinite(id)) {
      return false;
    }
    if (id < MIN_MOVIE_ID || id > MAX_MOVIE_ID) {
      return false;
    }
    if (!Number.isInteger(id)) {
      return false;
    }
    return true;
  }
  /**
   * Validates pagination parameters
   */
  isValidPaginationParams(page, limit) {
    if (page !== void 0) {
      if (!Number.isInteger(page) || page < 1 || page > 1e3) {
        return false;
      }
    }
    if (limit !== void 0) {
      if (!Number.isInteger(limit) || limit < 1 || limit > 250) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sanitizes search query by removing dangerous characters
   */
  sanitizeQuery(query) {
    return query.trim().replace(/\s+/g, " ").replace(/[<>]/g, "").substring(0, MAX_QUERY_LENGTH);
  }
  /**
   * Sanitizes token by keeping only allowed characters
   */
  sanitizeToken(token) {
    return token.trim().replace(/[^A-Za-z0-9\-_\.]/g, "").substring(0, MAX_TOKEN_LENGTH);
  }
  /**
   * Validates complete request configuration
   */
  validateRequestConfig(config) {
    const errors = [];
    if (!this.isValidToken(config.token)) {
      errors.push(t("validation.invalidApiToken"));
    }
    if (config.query !== void 0 && !this.isValidSearchQuery(config.query)) {
      errors.push(t("validation.invalidSearchQuery"));
    }
    if (config.movieId !== void 0 && !this.isValidMovieId(config.movieId)) {
      errors.push(t("validation.invalidMovieId"));
    }
    if (!this.isValidPaginationParams(config.page, config.limit)) {
      errors.push(t("validation.invalidPaginationParams"));
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
};

// APIProvider/provider.ts
init_i18n();
var API_BASE_URL = "https://api.themoviedb.org/3";
var MAX_SEARCH_RESULTS = 20;
var LANGUAGE = "ru-RU";
var IMAGE_BASE_URL = "https://image.tmdb.org/t/p/";
var TMDBProvider = class {
  constructor(settings) {
    this.errorHandler = new ErrorHandler();
    this.dataFormatter = new DataFormatter();
    this.validator = new ApiValidator();
    if (settings) {
      this.dataFormatter.setSettings(settings);
    }
  }
  /**
   * Performs HTTP GET request to TMDB API
   */
  async apiGet(endpoint, token, params = {}) {
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequired"));
    }
    params.language = LANGUAGE;
    const url = this.buildUrl(endpoint, params);
    try {
      const res = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          accept: "application/json",
          Authorization: "Bearer " + token
        }
      });
      return res.json;
    } catch (error) {
      throw this.errorHandler.handleApiError(error);
    }
  }
  /**
   * Builds URL with query parameters
   */
  buildUrl(endpoint, params) {
    const url = new URL(`${API_BASE_URL}${endpoint}`);
    for (const [key, value] of Object.entries(params)) {
      if (value !== void 0 && value !== null && value !== "") {
        url.searchParams.set(key, value.toString());
      }
    }
    return url.href;
  }
  /**
   * Calculate relevance score for search result
   */
  calculateRelevanceScore(item, query) {
    const normalizedQuery = query.toLowerCase().trim();
    const title = (item.title || item.name || "").toLowerCase();
    const originalTitle = (item.original_title || item.original_name || "").toLowerCase();
    let score = 0;
    if (title === normalizedQuery || originalTitle === normalizedQuery) {
      score += 1e3;
    }
    if (title.startsWith(normalizedQuery) || originalTitle.startsWith(normalizedQuery)) {
      score += 500;
    }
    if (title.includes(normalizedQuery) || originalTitle.includes(normalizedQuery)) {
      score += 250;
    }
    score += (item.vote_average || 0) * 10;
    score += (item.popularity || 0) * 0.1;
    return score;
  }
  /**
   * Search for movies and TV shows by query
   */
  async searchByQuery(query, token) {
    if (!this.validator.isValidSearchQuery(query)) {
      throw new Error(t("provider.enterMovieTitle"));
    }
    const [movieResults, tvResults] = await Promise.all([
      this.searchMovies(query, token),
      this.searchTVShows(query, token)
    ]);
    const combined = [...movieResults, ...tvResults].map((item) => {
      var _a, _b;
      return {
        item,
        score: this.calculateRelevanceScore({
          title: item.name,
          original_title: item.alternativeName,
          vote_average: ((_a = item.rating) == null ? void 0 : _a.tmdb) || 0,
          popularity: ((_b = item.rating) == null ? void 0 : _b.imdb) || 0
        }, query)
      };
    }).sort((a, b) => b.score - a.score).map((entry) => entry.item).slice(0, MAX_SEARCH_RESULTS);
    if (combined.length === 0) {
      throw new Error(
        tWithParams("provider.nothingFound", { query }) + " " + t("provider.tryChangeQuery")
      );
    }
    return combined;
  }
  /**
   * Search for movies only
   */
  async searchMovies(query, token) {
    const response = await this.apiGet(
      "/search/movie",
      token,
      {
        query: query.trim(),
        page: 1
      }
    );
    return (response.results || []).map((item) => this.convertToSuggestItem(item, "movie"));
  }
  /**
   * Search for TV shows only
   */
  async searchTVShows(query, token) {
    const response = await this.apiGet(
      "/search/tv",
      token,
      {
        query: query.trim(),
        page: 1
      }
    );
    return (response.results || []).map((item) => this.convertToSuggestItem(item, "tv-series"));
  }
  /**
   * Get all available images for a movie/TV show
   */
  async getAllImages(id, token, type) {
    try {
      const endpoint = type === "tv-series" ? `/tv/${id}/images` : `/movie/${id}/images`;
      const images = await this.apiGet(endpoint, token, {
        include_image_language: "ru,en,null"
      });
      const extractImageData = (imageArray = []) => {
        return imageArray.map((img) => ({
          url: `${IMAGE_BASE_URL}original${img.file_path}`,
          language: img.iso_639_1 || void 0
        })).filter((img) => img.url && img.url.trim() !== "");
      };
      return {
        posters: extractImageData(images.posters),
        backdrops: extractImageData(images.backdrops),
        logos: extractImageData(images.logos)
      };
    } catch (error) {
      console.error("Error fetching all images:", error);
      return { posters: [], backdrops: [], logos: [] };
    }
  }
  /**
   * Convert TMDB search result to TMDBSuggestItem format
   */
  convertToSuggestItem(item, type) {
    const title = item.title || item.name || "";
    const originalTitle = item.original_title || item.original_name || "";
    const year = item.release_date || item.first_air_date || "";
    return {
      id: item.id,
      name: title,
      alternativeName: originalTitle,
      type,
      year: year ? parseInt(year.substring(0, 4)) : 0,
      poster: item.poster_path ? {
        url: `${IMAGE_BASE_URL}w500${item.poster_path}`,
        previewUrl: `${IMAGE_BASE_URL}w185${item.poster_path}`
      } : void 0,
      rating: {
        tmdb: item.vote_average || 0,
        imdb: item.vote_average || 0
      }
    };
  }
  /**
   * Retrieves detailed movie/TV show information by ID and type
   */
  async getMovieById(id, token, type, userRating) {
    if (!this.validator.isValidMovieId(id)) {
      throw new Error(t("provider.invalidMovieId"));
    }
    if (!this.validator.isValidToken(token)) {
      throw new Error(t("provider.tokenRequiredForMovie"));
    }
    const processedUserRating = userRating === "" ? void 0 : userRating;
    if (type === "tv-series") {
      const tvData = await this.getTVShowDetails(id, token);
      return this.dataFormatter.createMovieShowFrom(tvData, processedUserRating);
    } else if (type === "movie") {
      const movieData = await this.getMovieDetails(id, token);
      return this.dataFormatter.createMovieShowFrom(movieData, processedUserRating);
    }
    try {
      const movieData = await this.getMovieDetails(id, token);
      return this.dataFormatter.createMovieShowFrom(movieData, processedUserRating);
    } catch (error) {
      const tvData = await this.getTVShowDetails(id, token);
      return this.dataFormatter.createMovieShowFrom(tvData, processedUserRating);
    }
  }
  /**
   * Get movie details from TMDB
   */
  async getMovieDetails(id, token) {
    const [details, credits, images] = await Promise.all([
      this.apiGet(`/movie/${id}`, token, {
        append_to_response: "videos,external_ids,alternative_titles,release_dates"
      }),
      this.apiGet(`/movie/${id}/credits`, token, {}),
      this.apiGet(`/movie/${id}/images`, token, {
        include_image_language: "ru,en,null"
      })
    ]);
    return this.dataFormatter.convertMovieToTMDBFormat(details, credits, images);
  }
  /**
   * Get TV show details from TMDB
   */
  async getTVShowDetails(id, token) {
    const [details, credits, images] = await Promise.all([
      this.apiGet(`/tv/${id}`, token, {
        append_to_response: "videos,external_ids,alternative_titles,content_ratings"
      }),
      this.apiGet(`/tv/${id}/credits`, token, {}),
      this.apiGet(`/tv/${id}/images`, token, {
        include_image_language: "ru,en,null"
      })
    ]);
    return this.dataFormatter.convertTVShowToTMDBFormat(details, credits, images);
  }
  /**
   * Validates API token by making test request
   */
  async validateToken(token) {
    if (!this.validator.isValidToken(token)) {
      return false;
    }
    try {
      await this.apiGet("/configuration", token, {});
      return true;
    } catch (e) {
      return false;
    }
  }
};
var provider = new TMDBProvider();

// Views/search_modal.ts
init_i18n();
var SearchModal = class extends import_obsidian3.Modal {
  constructor(plugin, callback) {
    super(plugin.app);
    this.callback = callback;
    this.isBusy = false;
    this.query = "";
    this.token = "";
    // Enter key handler for search
    this.submitEnterCallback = (event) => {
      if (event.key === "Enter" && !event.isComposing) {
        this.search();
      }
    };
    this.token = plugin.settings.apiToken;
    this.TMDBProvider = new TMDBProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  // Manages UI loading state
  setBusy(busy) {
    var _a, _b, _c;
    this.isBusy = busy;
    (_a = this.okBtnRef) == null ? void 0 : _a.setDisabled(busy);
    (_b = this.okBtnRef) == null ? void 0 : _b.setButtonText(
      busy ? t("modals.searching") : t("modals.searchButton")
    );
    (_c = this.inputRef) == null ? void 0 : _c.setDisabled(busy);
  }
  // Validates input before search
  validateInput() {
    var _a, _b;
    if (!((_a = this.query) == null ? void 0 : _a.trim())) {
      new import_obsidian3.Notice(t("modals.enterMovieName"));
      return false;
    }
    if (!((_b = this.token) == null ? void 0 : _b.trim())) {
      new import_obsidian3.Notice(t("modals.needApiToken"));
      return false;
    }
    if (this.isBusy) {
      return false;
    }
    return true;
  }
  // Handles search errors
  handleSearchError(error) {
    const errorMessage = error instanceof Error ? error.message : t("modals.errorUnexpected");
    new import_obsidian3.Notice(errorMessage);
    this.callback(error);
  }
  // Performs search via TMDB API
  async search() {
    if (!this.validateInput()) {
      return;
    }
    try {
      this.setBusy(true);
      const searchResults = await this.TMDBProvider.searchByQuery(
        this.query.trim(),
        this.token
      );
      this.callback(null, searchResults);
      this.close();
    } catch (error) {
      this.handleSearchError(error);
    } finally {
      this.setBusy(false);
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: t("modals.searchTitle") });
    contentEl.createDiv(
      { cls: "TMDB-plugin__search-modal--input" },
      (settingItem) => {
        this.inputRef = new import_obsidian3.TextComponent(settingItem).setValue(this.query).setPlaceholder(t("modals.searchPlaceholder")).onChange((value) => this.query = value);
        this.inputRef.inputEl.addEventListener(
          "keydown",
          this.submitEnterCallback
        );
      }
    );
    new import_obsidian3.Setting(contentEl).addButton((btn) => {
      return this.okBtnRef = btn.setButtonText(t("modals.searchButton")).setCta().onClick(() => {
        this.search();
      });
    });
  }
  onClose() {
    var _a;
    if ((_a = this.inputRef) == null ? void 0 : _a.inputEl) {
      this.inputRef.inputEl.removeEventListener(
        "keydown",
        this.submitEnterCallback
      );
    }
    this.contentEl.empty();
  }
};

// Views/suggest_modal.ts
var import_obsidian8 = require("obsidian");
init_imageUtils();

// Views/image_selection_modal.ts
var import_obsidian5 = require("obsidian");
var ImageApprovalModal = class extends import_obsidian5.Modal {
  constructor(app, data, onConfirm) {
    super(app);
    this.data = data;
    this.onConfirm = onConfirm;
    this.isListView = false;
    this.activeViewType = "poster";
  }
  sortImages(images) {
    const getLangPriority = (lang) => {
      if (lang === "ru") return 1;
      if (lang === "en") return 2;
      return 3;
    };
    return [...images].sort((a, b) => {
      const priorityA = getLangPriority(a.language);
      const priorityB = getLangPriority(b.language);
      return priorityA - priorityB;
    });
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("TMDB-plugin__image-approval-modal");
    if (this.isListView) {
      this.renderListView();
    } else {
      this.renderSummaryView();
    }
  }
  // ---  1:  ( ) ---
  renderSummaryView() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F" });
    const scrollContainer = contentEl.createDiv({ cls: "TMDB-plugin__summary-scroll" });
    const posterInfo = this.data.poster.all.find((img) => img.url === this.data.poster.current);
    const coverInfo = this.data.cover.all.find((img) => img.url === this.data.cover.current);
    const logoInfo = this.data.logo.all.find((img) => img.url === this.data.logo.current);
    this.createSummarySection(scrollContainer, "\u041F\u043E\u0441\u0442\u0435\u0440", this.data.poster.current, "poster", posterInfo == null ? void 0 : posterInfo.language);
    this.createSummarySection(scrollContainer, "\u041E\u0431\u043B\u043E\u0436\u043A\u0430", this.data.cover.current, "cover", coverInfo == null ? void 0 : coverInfo.language);
    this.createSummarySection(scrollContainer, "\u041B\u043E\u0433\u043E\u0442\u0438\u043F", this.data.logo.current, "logo", logoInfo == null ? void 0 : logoInfo.language);
    const footer = contentEl.createDiv({ cls: "TMDB-plugin__button-container" });
    const setting = new import_obsidian5.Setting(footer);
    setting.addButton(
      (btn) => btn.setButtonText("\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435 \u043F\u043E\u0448\u0430\u0433\u043E\u0432\u043E").onClick(() => {
        this.backupData = JSON.parse(JSON.stringify(this.data));
        this.activeViewType = "poster";
        this.isListView = true;
        this.render();
      })
    );
    setting.addButton(
      (btn) => btn.setButtonText("\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C").setCta().onClick(() => {
        this.onConfirm({
          poster: this.data.poster.current,
          cover: this.data.cover.current,
          logo: this.data.logo.current
        });
        this.close();
      })
    );
  }
  createSummarySection(parent, title, url, type, language) {
    const card = parent.createDiv({ cls: "TMDB-plugin__summary-section" });
    const header = card.createDiv({ cls: "TMDB-plugin__summary-header" });
    header.createEl("h3", { text: title });
    const imgFrame = card.createDiv({ cls: `TMDB-plugin__summary-image-frame is-${type}` });
    if (url) {
      if (language) {
        imgFrame.createDiv({
          cls: "TMDB-plugin__language-badge",
          text: language.toUpperCase()
        });
      }
      const img = imgFrame.createEl("img");
      img.src = url;
      if (type === "logo") img.addClass("is-contain");
    } else {
      imgFrame.addClass("is-empty");
      imgFrame.createDiv({ text: "\u041D\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F", cls: "empty-text" });
    }
    const actionContainer = card.createDiv({ cls: "TMDB-plugin__summary-actions" });
    new import_obsidian5.Setting(actionContainer).addButton(
      (btn) => btn.setButtonText("\u0418\u0437\u043C\u0435\u043D\u0438\u0442\u044C").setClass("mod-ghost").onClick(() => {
        this.backupData = JSON.parse(JSON.stringify(this.data));
        this.activeViewType = type;
        this.isListView = true;
        this.render();
      })
    );
  }
  renderListView() {
    const { contentEl } = this;
    const currentType = this.activeViewType;
    const listData = this.data[currentType];
    contentEl.empty();
    const headerDiv = contentEl.createDiv({ cls: "TMDB-plugin__list-header" });
    const titles = {
      "poster": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041F\u043E\u0441\u0442\u0435\u0440",
      "cover": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041E\u0431\u043B\u043E\u0436\u043A\u0443",
      "logo": "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u041B\u043E\u0433\u043E\u0442\u0438\u043F"
    };
    headerDiv.createEl("h2", { text: titles[currentType] || currentType });
    const gridContainer = contentEl.createDiv({ cls: "TMDB-plugin__images-grid" });
    gridContainer.addClass(`is-${currentType}`);
    const sortedImages = this.sortImages(listData.all);
    sortedImages.forEach((imageInfo) => {
      const { url, language } = imageInfo;
      const imgWrapper = gridContainer.createDiv({
        cls: `TMDB-plugin__grid-item ${url === listData.current ? "is-selected" : ""}`
      });
      if (language) {
        imgWrapper.createDiv({
          cls: "TMDB-plugin__language-badge",
          text: language.toUpperCase()
        });
      }
      const img = imgWrapper.createEl("img");
      img.src = url;
      imgWrapper.addEventListener("click", () => {
        this.data[currentType].current = url;
        this.isListView = false;
        this.activeViewType = "poster";
        this.render();
      });
    });
    const footer = contentEl.createDiv({ cls: "TMDB-plugin__button-container" });
    new import_obsidian5.Setting(footer).addButton((btn) => btn.setButtonText("\u041D\u0430\u0437\u0430\u0434 \u043A \u0441\u0432\u043E\u0434\u043A\u0435").onClick(() => {
      if (this.backupData) {
        this.data[currentType].current = this.backupData[currentType].current;
      }
      this.isListView = false;
      this.render();
    }));
  }
  onOpen() {
    this.render();
  }
};

// Views/status_selection_modal.ts
var import_obsidian7 = require("obsidian");
init_i18n();

// Views/rating_input_modal.ts
var import_obsidian6 = require("obsidian");
init_i18n();
var RatingInputModal = class extends import_obsidian6.Modal {
  constructor(app, onChooseRating) {
    super(app);
    this.rating = null;
    this.onChooseRating = onChooseRating;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("TMDB-plugin__rating-input-modal");
    contentEl.createEl("h2", { text: t("modals.rateMovie") });
    const ratingContainer = contentEl.createDiv({ cls: "rating-input-container" });
    const numberRatingContainer = ratingContainer.createDiv({ cls: "number-rating" });
    for (let i = 0; i <= 10; i++) {
      const numberButton = numberRatingContainer.createSpan({
        text: i.toString(),
        cls: "number-button",
        attr: { "data-rating": i.toString() }
      });
      numberButton.style.fontSize = "1rem";
      numberButton.style.cursor = "pointer";
      numberButton.style.margin = "0 1px";
      numberButton.style.padding = "6px 8px";
      numberButton.style.border = "2px solid #d1d5db";
      numberButton.style.borderRadius = "4px";
      numberButton.style.display = "inline-block";
      numberButton.style.textAlign = "center";
      numberButton.style.width = "30px";
      numberButton.style.height = "30px";
      numberButton.style.lineHeight = "18px";
      numberButton.style.boxSizing = "border-box";
      numberButton.addEventListener("click", () => {
        this.rating = i;
        this.updateNumberDisplay(i);
      });
      numberButton.addEventListener("mouseover", () => {
        this.highlightNumbers(i);
      });
      numberButton.addEventListener("mouseout", () => {
        this.resetNumberDisplay();
        if (this.rating !== null) {
          this.updateNumberDisplay(this.rating);
        }
      });
    }
    const numericInputContainer = ratingContainer.createDiv({ cls: "numeric-input" });
    numericInputContainer.createEl("label", { text: `${t("modals.ratingValue")}: ` });
    const numericInput = numericInputContainer.createEl("input", {
      type: "number",
      placeholder: t("modals.enterRatingPlaceholder")
    });
    numericInput.setAttribute("min", "0");
    numericInput.setAttribute("max", "10");
    numericInput.setAttribute("step", "0.5");
    numericInput.addEventListener("input", (e) => {
      const value = parseFloat(e.target.value);
      if (!isNaN(value) && value >= 0 && value <= 10) {
        this.rating = value;
        this.updateNumberDisplay(Math.round(value));
      } else if (e.target.value === "") {
        this.rating = null;
        this.resetNumberDisplay();
      }
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian6.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText(t("common.ok")).setCta().onClick(() => {
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText(t("common.skip")).onClick(() => {
        this.rating = null;
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText(t("common.cancel")).onClick(() => {
        this.rating = null;
        this.close();
      })
    );
  }
  updateNumberDisplay(selectedRating) {
    const numberButtons = this.contentEl.querySelectorAll(".number-button");
    numberButtons.forEach((button) => {
      const buttonElement = button;
      const ratingValue = parseInt(buttonElement.getAttribute("data-rating") || "0");
      if (ratingValue === selectedRating) {
        buttonElement.style.backgroundColor = "#3b82f6";
        buttonElement.style.color = "white";
        buttonElement.style.borderColor = "#3b82f6";
      } else {
        buttonElement.style.backgroundColor = "";
        buttonElement.style.color = "";
        buttonElement.style.borderColor = "#d1d5db";
      }
    });
  }
  highlightNumbers(toRating) {
    const numberButtons = this.contentEl.querySelectorAll(".number-button");
    numberButtons.forEach((button) => {
      const buttonElement = button;
      const ratingValue = parseInt(buttonElement.getAttribute("data-rating") || "0");
      if (ratingValue <= toRating) {
        buttonElement.style.backgroundColor = "#93c5fd";
        buttonElement.style.color = "black";
      } else {
        buttonElement.style.backgroundColor = "";
        buttonElement.style.color = "";
      }
    });
  }
  resetNumberDisplay() {
    const numberButtons = this.contentEl.querySelectorAll(".number-button");
    numberButtons.forEach((button) => {
      const buttonElement = button;
      const ratingValue = parseInt(buttonElement.getAttribute("data-rating") || "0");
      if (this.rating !== null && ratingValue === this.rating) {
        buttonElement.style.backgroundColor = "#3b82f6";
        buttonElement.style.color = "white";
        buttonElement.style.borderColor = "#3b82f6";
      } else {
        buttonElement.style.backgroundColor = "";
        buttonElement.style.color = "";
        buttonElement.style.borderColor = "#d1d5db";
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.onChooseRating(this.rating === null ? "" : this.rating);
  }
};

// Views/status_selection_modal.ts
var StatusSelectionModal = class extends import_obsidian7.Modal {
  constructor(app, statusOptions, onChooseStatus) {
    super(app);
    this.statusOptions = statusOptions;
    this.selectedStatus = null;
    this.onChooseStatus = onChooseStatus;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("TMDB-plugin__status-selection-modal");
    contentEl.createEl("h2", { text: t("status.selectStatus") });
    const optionsContainer = contentEl.createDiv({ cls: "status-options-container" });
    this.statusOptions.forEach((status) => {
      const statusIcons = {
        [t("status.willWatch")]: "bookmark",
        [t("status.haveWatched")]: "check-circle",
        [t("status.watching")]: "eye",
        [t("status.dropped")]: "x-circle"
      };
      const iconName = statusIcons[status] || "star";
      const setting = new import_obsidian7.Setting(optionsContainer).setName(status);
      const iconEl = setting.nameEl.createSpan({ cls: "status-icon" });
      (0, import_obsidian7.setIcon)(iconEl, iconName);
      setting.nameEl.prepend(iconEl);
      setting.settingEl.style.cursor = "pointer";
      setting.settingEl.onclick = () => {
        this.selectedStatus = status;
        if (status === t("status.haveWatched")) {
          this.close();
          setTimeout(() => {
            new RatingInputModal(this.app, (rating) => {
              this.onChooseStatus(this.selectedStatus, rating);
            }).open();
          }, 100);
        } else {
          this.close();
        }
      };
    });
    const skipSetting = new import_obsidian7.Setting(contentEl).setName(t("status.skip")).setDesc(`${t("status.useDefault")} (${t("status.defaultStatus")})`);
    const skipIconEl = skipSetting.nameEl.createSpan({ cls: "status-icon" });
    (0, import_obsidian7.setIcon)(skipIconEl, "forward");
    skipSetting.nameEl.prepend(skipIconEl);
    skipSetting.settingEl.style.cursor = "pointer";
    skipSetting.settingEl.onclick = () => {
      this.selectedStatus = null;
      this.close();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.selectedStatus !== t("status.haveWatched")) {
      this.onChooseStatus(this.selectedStatus, null);
    }
  }
};

// Views/suggest_modal.ts
init_i18n();
var toImageInfoArray = (items) => {
  if (!items) return [];
  return items.map((item) => typeof item === "string" ? { url: item } : item);
};
var ItemsSuggestModal = class extends import_obsidian8.SuggestModal {
  constructor(plugin, suggestion, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestion = suggestion;
    this.onChoose = onChoose;
    this.token = "";
    this.token = plugin.settings.apiToken;
    this.TMDBProvider = new TMDBProvider({
      actorsPath: plugin.settings.actorsPath,
      directorsPath: plugin.settings.directorsPath,
      writersPath: plugin.settings.writersPath,
      producersPath: plugin.settings.producersPath
    });
  }
  getSuggestions(query) {
    return this.suggestion.filter((item) => {
      const searchQuery = query == null ? void 0 : query.toLowerCase();
      return item.name.toLowerCase().includes(searchQuery) || item.alternativeName.toLowerCase().includes(searchQuery);
    });
  }
  isValidImageUrl(url) {
    if (!url || url.trim() === "") return false;
    try {
      new URL(url);
      return url.startsWith("http://") || url.startsWith("https://");
    } catch (e) {
      return false;
    }
  }
  createPosterElement(item, container) {
    var _a;
    const posterUrl = (_a = item.poster) == null ? void 0 : _a.url;
    if (this.isValidImageUrl(posterUrl)) {
      const imgElement = container.createEl("img", {
        cls: "TMDB-plugin__suggest-poster"
      });
      imgElement.src = posterUrl;
      imgElement.addEventListener("error", () => {
        const placeholder = container.createEl("div", {
          text: t("modals.posterPlaceholderEmoji"),
          cls: "TMDB-plugin__suggest-poster-placeholder"
        });
        placeholder.title = t("modals.posterTooltipGeoblock");
        imgElement.replaceWith(placeholder);
      });
      return imgElement;
    } else {
      const placeholder = container.createEl("div", {
        text: t("modals.posterPlaceholderEmoji"),
        cls: "TMDB-plugin__suggest-poster-placeholder"
      });
      const reason = !posterUrl ? t("modals.posterTooltipMissing") : posterUrl.trim() === "" ? t("modals.posterTooltipEmptyLink") : t("modals.posterTooltipInvalidLink");
      placeholder.title = reason;
      return placeholder;
    }
  }
  renderSuggestion(item, el) {
    var _a, _b, _c, _d;
    el.addClass("TMDB-plugin__suggest-item");
    const title = item.name;
    const subtitle = `${t("common.type")}: ${item.type}, ${t("ratings.year")}: ${item.year}, TMDB: ${Number((_b = (_a = item.rating) == null ? void 0 : _a.tmdb) == null ? void 0 : _b.toFixed(0))}, IMDB: ${Number((_d = (_c = item.rating) == null ? void 0 : _c.imdb) == null ? void 0 : _d.toFixed(0))} `;
    this.createPosterElement(item, el);
    const textInfo = el.createEl("div", {
      cls: "TMDB-plugin__suggest-text-info"
    });
    textInfo.createEl("div", { text: title });
    textInfo.createEl("small", { text: subtitle });
  }
  onChooseSuggestion(item) {
    this.getItemDetails(item);
  }
  updateStatus(message, persistent = true) {
    this.hideLoadingNotice();
    this.loadingNotice = new import_obsidian8.Notice(message, persistent ? 0 : 3e3);
  }
  hideLoadingNotice() {
    if (this.loadingNotice) {
      this.loadingNotice.hide();
      this.loadingNotice = void 0;
    }
  }
  updateLoadingNotice(message) {
    if (this.loadingNotice) {
      const noticeEl = this.loadingNotice.noticeEl;
      if (noticeEl) {
        noticeEl.textContent = message;
      }
    } else {
      this.updateStatus(message);
    }
  }
  createProgressText(current, total, task) {
    if (total === 0) return task;
    const percentage = Math.round(current / total * 100);
    const progressBar = this.createProgressBar(current, total);
    return `${task}
${progressBar} ${current}/${total} (${percentage}%)`;
  }
  createProgressBar(current, total, length = 20) {
    if (total === 0) return "";
    const filled = Math.round(current / total * length);
    const empty = length - filled;
    return "\u2588".repeat(filled) + "\u2591".repeat(empty);
  }
  validateInput(item) {
    var _a;
    if (!(item == null ? void 0 : item.id) || item.id <= 0) {
      new import_obsidian8.Notice(t("modals.errorMovieData"));
      this.onChoose(new Error(t("modals.errorMovieData")));
      return false;
    }
    if (!((_a = this.token) == null ? void 0 : _a.trim())) {
      new import_obsidian8.Notice(t("modals.needApiToken"));
      this.onChoose(new Error(t("modals.needApiToken")));
      return false;
    }
    return true;
  }
  async fetchMovieData(itemId, type) {
    return await this.TMDBProvider.getMovieById(itemId, this.token, type);
  }
  async processImageApprovals(movieShow, itemId, itemType) {
    this.updateLoadingNotice(t("modals.loadingAlternativeImages"));
    const allImages = await this.TMDBProvider.getAllImages(
      itemId,
      this.token,
      itemType
    );
    this.hideLoadingNotice();
    return new Promise(async (resolve) => {
      const modal = new ImageApprovalModal(
        this.app,
        {
          // FIXED:    
          poster: {
            current: movieShow.posterUrl[0] || "",
            all: toImageInfoArray(allImages.posters)
          },
          cover: {
            current: movieShow.coverUrl[0] || "",
            all: toImageInfoArray(allImages.backdrops)
          },
          logo: {
            current: movieShow.logoUrl[0] || "",
            all: toImageInfoArray(allImages.logos)
          }
        },
        async (finalSelection) => {
          movieShow.posterUrl = finalSelection.poster ? [finalSelection.poster] : [];
          movieShow.coverUrl = finalSelection.cover ? [finalSelection.cover] : [];
          movieShow.logoUrl = finalSelection.logo ? [finalSelection.logo] : [];
          const statusOptions = [
            t("status.willWatch"),
            t("status.haveWatched"),
            t("status.watching"),
            t("status.dropped")
          ];
          new StatusSelectionModal(this.app, statusOptions, (selectedStatus, rating) => {
            movieShow.status = selectedStatus || t("status.willWatch");
            if (rating !== null && rating !== void 0 && rating !== "") {
              movieShow.userRating = rating;
            }
            resolve(movieShow);
          }).open();
        }
      );
      modal.open();
    });
  }
  handleSuccess(movieShow, hadImageProcessing = false) {
    this.hideLoadingNotice();
    if (!hadImageProcessing) {
      new import_obsidian8.Notice(t("modals.movieInfoLoaded"));
    }
    this.onChoose(null, movieShow);
  }
  handleError(error) {
    this.hideLoadingNotice();
    const errorMessage = error instanceof Error ? error.message : t("modals.errorGettingDetails");
    new import_obsidian8.Notice(errorMessage);
    console.error("Error getting movie details:", error);
    this.onChoose(error);
  }
  async getItemDetails(item) {
    if (!this.validateInput(item)) {
      return;
    }
    try {
      this.updateStatus(t("modals.loadingMovieInfo"));
      let movieShow = await this.fetchMovieData(item.id, item.type);
      if (!this.plugin.settings.saveImagesLocally) {
        this.handleSuccess(movieShow, false);
        return;
      }
      movieShow = await this.processImageApprovals(movieShow, item.id, item.type);
      let imageProcessingCompleted = false;
      const imageSettings = {
        saveImagesLocally: true,
        imagesFolder: this.plugin.settings.imagesFolder,
        savePosterImage: this.plugin.settings.savePosterImage && movieShow.posterUrl.length > 0,
        saveCoverImage: this.plugin.settings.saveCoverImage && movieShow.coverUrl.length > 0,
        saveLogoImage: this.plugin.settings.saveLogoImage && movieShow.logoUrl.length > 0,
        imageFileNameFormat: this.plugin.settings.imageFileNameFormat
      };
      const anyImageToDownload = imageSettings.savePosterImage || imageSettings.saveCoverImage || imageSettings.saveLogoImage;
      if (!anyImageToDownload) {
        this.handleSuccess(movieShow, false);
        return;
      }
      this.updateLoadingNotice(t("modals.preparingImages"));
      const progressCallback = (current, total, currentTask) => {
        const progressText = this.createProgressText(
          current,
          total,
          currentTask
        );
        this.updateLoadingNotice(progressText);
        if (current === total) {
          imageProcessingCompleted = true;
        }
      };
      const processedMovieShow = await processImages(
        this.plugin.app,
        movieShow,
        imageSettings,
        progressCallback
      );
      if (imageProcessingCompleted) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      this.handleSuccess(processedMovieShow, true);
    } catch (error) {
      this.handleError(error);
    }
  }
  onClose() {
    this.hideLoadingNotice();
    super.onClose();
  }
};

// main.ts
init_i18n();

// Settings/settings.ts
var import_obsidian11 = require("obsidian");

// Settings/Suggesters/FolderSuggester.ts
var import_obsidian9 = require("obsidian");
init_i18n();
var FolderSuggest = class extends import_obsidian9.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFolder) {
    super(app, textInputEl);
    this.onSelectFolder = onSelectFolder;
  }
  /**
   * Get folders matching input text
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const folders = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((folder) => {
        if (folder instanceof import_obsidian9.TFolder && folder.path.toLowerCase().includes(lowerCaseInputStr)) {
          folders.push(folder);
        }
      });
      return folders.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.folderListError"), error);
      return [];
    }
  }
  renderSuggestion(folder, el) {
    if (folder && el) {
      el.setText(folder.path);
    }
  }
  selectSuggestion(folder) {
    if (folder && folder.path) {
      this.setValue(folder.path);
      this.onSelectFolder(folder.path);
      this.close();
    }
  }
};

// Settings/Suggesters/FileSuggester.ts
var import_obsidian10 = require("obsidian");
init_i18n();
var FileSuggest = class extends import_obsidian10.AbstractInputSuggest {
  constructor(app, textInputEl, onSelectFile) {
    super(app, textInputEl);
    this.onSelectFile = onSelectFile;
  }
  /**
   * Get files matching input text - filters only .md files
   */
  getSuggestions(inputStr) {
    if (!inputStr) {
      return [];
    }
    try {
      const abstractFiles = this.app.vault.getAllLoadedFiles();
      const files = [];
      const lowerCaseInputStr = inputStr.toLowerCase();
      abstractFiles.forEach((file) => {
        if (file instanceof import_obsidian10.TFile && file.extension === "md" && file.path.toLowerCase().includes(lowerCaseInputStr)) {
          files.push(file);
        }
      });
      return files.slice(0, 20);
    } catch (error) {
      console.error(t("suggesters.fileListError"), error);
      return [];
    }
  }
  renderSuggestion(file, el) {
    if (file && el) {
      el.setText(file.path);
    }
  }
  selectSuggestion(file) {
    if (file && file.path) {
      this.setValue(file.path);
      this.onSelectFile(file.path);
      this.close();
    }
  }
};

// Settings/settings.ts
init_i18n();
var docUrl = "https://github.com/2PleXXX/obsidian-TMDB-search-plus-plugin";
var apiSite = "https://TMDB.dev/";
var DEFAULT_SETTINGS = {
  language: "en",
  apiToken: "",
  apiTokenValid: false,
  movieFileNameFormat: "",
  movieFolder: "",
  movieTemplateFile: "",
  seriesFileNameFormat: "",
  seriesFolder: "",
  seriesTemplateFile: "",
  // Image settings
  actorsPath: "",
  directorsPath: "",
  writersPath: "",
  producersPath: "",
  // Image defaults
  imagesFolder: "attachments/TMDB",
  saveImagesLocally: false,
  savePosterImage: true,
  saveCoverImage: false,
  saveLogoImage: false,
  imageFileNameFormat: "{{nameForFile}}_{{id}}_{{type}}",
  // Default format with name, id, and type
  // Mobile settings
  mobileCoverHeightMultiplier: 1.5
};
var ObsidianTMDBSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.validationTimeout = null;
    this.TMDBProvider = new TMDBProvider();
    setLanguage(this.plugin.settings.language);
  }
  get settings() {
    return this.plugin.settings;
  }
  onClose() {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }
  }
  /**
   * Update token validation visual indicator
   */
  updateTokenValidationIndicator(inputElement, isValid) {
    if (!inputElement) return;
    inputElement.removeClass(
      "TMDB-plugin__token-valid",
      "TMDB-plugin__token-invalid",
      "TMDB-plugin__token-checking"
    );
    if (this.plugin.settings.apiToken.trim() !== "") {
      if (isValid === null) {
        inputElement.addClass("TMDB-plugin__token-checking");
      } else if (isValid) {
        inputElement.addClass("TMDB-plugin__token-valid");
      } else {
        inputElement.addClass("TMDB-plugin__token-invalid");
      }
    }
  }
  /**
   * Validate token with delay
   */
  async validateTokenWithDelay(token, inputElement) {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
    }
    this.updateTokenValidationIndicator(inputElement, null);
    this.validationTimeout = setTimeout(async () => {
      try {
        const isValid = await this.TMDBProvider.validateToken(
          token
        );
        this.plugin.settings.apiTokenValid = isValid;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, isValid);
      } catch (error) {
        console.error("Token validation error:", error);
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        this.updateTokenValidationIndicator(inputElement, false);
      }
    }, 1500);
  }
  /**
   * Create folder selection setting
   */
  createFolderSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FolderSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FolderSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  /**
   * Create template file selection setting
   */
  createTemplateSetting(containerEl, name, desc, placeholder, currentValue, onValueChange) {
    new import_obsidian11.Setting(containerEl).setName(name).setDesc(desc).addSearch((cb) => {
      try {
        new FileSuggest(this.app, cb.inputEl, onValueChange);
      } catch (error) {
        console.error("Error creating FileSuggest:", error);
      }
      cb.setPlaceholder(placeholder).setValue(currentValue).onChange(onValueChange);
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("obsidian-TMDB-plugin__settings");
    new import_obsidian11.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const languages = getSupportedLanguages();
      languages.forEach((lang) => {
        dropdown.addOption(lang.code, lang.name);
      });
      dropdown.setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        setLanguage(value);
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const apiKeyDesc = document.createDocumentFragment();
    apiKeyDesc.createDiv({
      text: t("settings.apiTokenDesc")
    });
    apiKeyDesc.createEl("a", {
      text: t("settings.getApiToken"),
      href: apiSite
    });
    let tokenInputElement;
    new import_obsidian11.Setting(containerEl).setName(t("settings.apiToken")).setDesc(apiKeyDesc).addText((text) => {
      const textComponent = text.setPlaceholder(t("settings.enterToken")).setValue(this.plugin.settings.apiToken).onChange(async (value) => {
        this.plugin.settings.apiToken = value.trim();
        this.plugin.settings.apiTokenValid = false;
        await this.plugin.saveSettings();
        if (value.trim() !== "") {
          await this.validateTokenWithDelay(
            value.trim(),
            textComponent.inputEl
          );
        } else {
          if (this.validationTimeout) {
            clearTimeout(this.validationTimeout);
            this.validationTimeout = null;
          }
          this.updateTokenValidationIndicator(
            textComponent.inputEl,
            false
          );
        }
      });
      tokenInputElement = textComponent.inputEl;
      if (this.plugin.settings.apiToken.trim() !== "") {
        this.updateTokenValidationIndicator(
          textComponent.inputEl,
          this.plugin.settings.apiTokenValid
        );
      }
      return textComponent;
    }).addButton(
      (button) => button.setButtonText(t("settings.checkToken")).setCta().onClick(async () => {
        const token = this.plugin.settings.apiToken.trim();
        if (!token) {
          new import_obsidian11.Notice(t("settings.enterToken"));
          return;
        }
        button.setDisabled(true);
        button.setButtonText(t("settings.checking"));
        try {
          new import_obsidian11.Notice(t("settings.checking"));
          const isValid = await this.TMDBProvider.validateToken(
            token
          );
          this.plugin.settings.apiTokenValid = isValid;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            isValid
          );
          new import_obsidian11.Notice(
            isValid ? t("settings.tokenValid") : t("settings.tokenInvalid")
          );
        } catch (error) {
          console.error(
            "Manual token validation error:",
            error
          );
          this.plugin.settings.apiTokenValid = false;
          await this.plugin.saveSettings();
          this.updateTokenValidationIndicator(
            tokenInputElement,
            false
          );
          new import_obsidian11.Notice(t("settings.tokenError"));
        } finally {
          button.setDisabled(false);
          button.setButtonText(t("settings.checkToken"));
        }
      })
    );
    new import_obsidian11.Setting(containerEl).setName(t("settings.imagesHeading")).setHeading();
    new import_obsidian11.Setting(containerEl).setName(t("settings.saveImagesLocally")).setDesc(t("settings.saveImagesLocallyDesc")).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.saveImagesLocally).onChange(async (value) => {
        this.plugin.settings.saveImagesLocally = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.saveImagesLocally) {
      this.createFolderSetting(
        containerEl,
        t("settings.imagesFolder"),
        t("settings.imagesFolderDesc"),
        t("settings.imagesFolderPlaceholder"),
        this.plugin.settings.imagesFolder,
        async (folder) => {
          this.plugin.settings.imagesFolder = folder;
          await this.plugin.saveSettings();
        }
      );
      new import_obsidian11.Setting(containerEl).setName(t("settings.savePosterImage")).setDesc(t("settings.savePosterImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.savePosterImage).onChange(async (value) => {
          this.plugin.settings.savePosterImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian11.Setting(containerEl).setName(t("settings.saveCoverImage")).setDesc(t("settings.saveCoverImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveCoverImage).onChange(async (value) => {
          this.plugin.settings.saveCoverImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian11.Setting(containerEl).setName(t("settings.saveLogoImage")).setDesc(t("settings.saveLogoImageDesc")).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.saveLogoImage).onChange(async (value) => {
          this.plugin.settings.saveLogoImage = value;
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian11.Setting(containerEl).setName(t("settings.imageFileNameFormat")).setDesc(t("settings.imageFileNameFormatDesc")).addText(
        (text) => text.setPlaceholder(t("settings.imageFileNameFormatPlaceholder")).setValue(this.plugin.settings.imageFileNameFormat).onChange(async (value) => {
          this.plugin.settings.imageFileNameFormat = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian11.Setting(containerEl).setName(t("settings.moviesHeading")).setHeading();
    new import_obsidian11.Setting(containerEl).setName(t("settings.movieFileName")).setDesc(t("settings.movieFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.movieFileNamePlaceholder")).setValue(this.plugin.settings.movieFileNameFormat).onChange(async (value) => {
        this.plugin.settings.movieFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.movieFileLocation"),
      t("settings.movieFileLocationDesc"),
      t("settings.movieFileLocationPlaceholder"),
      this.plugin.settings.movieFolder,
      async (folder) => {
        this.plugin.settings.movieFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const movieTemplateFileDesc = document.createDocumentFragment();
    movieTemplateFileDesc.createDiv({
      text: t("settings.movieTemplateFileDesc")
    });
    movieTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.movieTemplateFile"),
      movieTemplateFileDesc,
      t("settings.movieTemplateFilePlaceholder"),
      this.plugin.settings.movieTemplateFile,
      async (file) => {
        this.plugin.settings.movieTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian11.Setting(containerEl).setName(t("settings.seriesHeading")).setHeading();
    new import_obsidian11.Setting(containerEl).setName(t("settings.seriesFileName")).setDesc(t("settings.seriesFileNameDesc")).addText(
      (text) => text.setPlaceholder(t("settings.seriesFileNamePlaceholder")).setValue(this.plugin.settings.seriesFileNameFormat).onChange(async (value) => {
        this.plugin.settings.seriesFileNameFormat = value;
        await this.plugin.saveSettings();
      })
    );
    this.createFolderSetting(
      containerEl,
      t("settings.seriesFileLocation"),
      t("settings.seriesFileLocationDesc"),
      t("settings.seriesFileLocationPlaceholder"),
      this.plugin.settings.seriesFolder,
      async (folder) => {
        this.plugin.settings.seriesFolder = folder;
        await this.plugin.saveSettings();
      }
    );
    const seriesTemplateFileDesc = document.createDocumentFragment();
    seriesTemplateFileDesc.createDiv({
      text: t("settings.seriesTemplateFileDesc")
    });
    seriesTemplateFileDesc.createEl("a", {
      text: t("settings.exampleTemplate"),
      href: `${docUrl}#example-template`
    });
    this.createTemplateSetting(
      containerEl,
      t("settings.seriesTemplateFile"),
      seriesTemplateFileDesc,
      t("settings.seriesTemplateFilePlaceholder"),
      this.plugin.settings.seriesTemplateFile,
      async (file) => {
        this.plugin.settings.seriesTemplateFile = file;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian11.Setting(containerEl).setName(t("settings.peopleHeading")).setHeading();
    new import_obsidian11.Setting(containerEl).setName(t("settings.actorsFileLocation")).setDesc(t("settings.actorsFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.actorsPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.actorsFileLocationPlaceholder")).setValue(this.plugin.settings.actorsPath).onChange(async (newFolder) => {
        this.plugin.settings.actorsPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName(t("settings.directorsFileLocation")).setDesc(t("settings.directorsFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.directorsPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.directorsFileLocationPlaceholder")).setValue(this.plugin.settings.directorsPath).onChange(async (newFolder) => {
        this.plugin.settings.directorsPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName(t("settings.writersFileLocation")).setDesc(t("settings.writersFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.writersPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.writersFileLocationPlaceholder")).setValue(this.plugin.settings.writersPath).onChange(async (newFolder) => {
        this.plugin.settings.writersPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(containerEl).setName(t("settings.producersFileLocation")).setDesc(t("settings.producersFileLocationDesc")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl, (folder) => {
        this.plugin.settings.producersPath = folder;
        this.plugin.saveSettings();
      });
      cb.setPlaceholder(t("settings.producersFileLocationPlaceholder")).setValue(this.plugin.settings.producersPath).onChange(async (newFolder) => {
        this.plugin.settings.producersPath = newFolder;
        await this.plugin.saveSettings();
      });
    });
  }
};

// main.ts
init_utils();

// Utils/cursor_jumper.ts
var import_obsidian12 = require("obsidian");
var CursorJumper = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Move cursor to the beginning of active document
   */
  async jumpToNextCursorLocation() {
    try {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
      if (!(activeView == null ? void 0 : activeView.file)) {
        return;
      }
      const editor = activeView.editor;
      if (!editor) {
        return;
      }
      editor.focus();
      editor.setCursor(0, 0);
    } catch (error) {
      console.error("Error moving cursor:", error);
    }
  }
};

// main.ts
init_i18n();
var ObsidianTMDBPlugin = class extends import_obsidian13.Plugin {
  async onload() {
    await this.loadSettings();
    initializeLanguage(this.settings.language);
    this.addRibbonIcon("film", "Search in TMDB", () => {
      this.createNewNote();
    });
    this.addCommand({
      id: "search",
      name: "Search",
      callback: () => {
        this.createNewNote();
      }
    });
    this.addCommand({
      id: "analyze-res-notes",
      name: "Analyze current note for _res poster and update ratings",
      callback: async () => {
        await this.analyzeResNotes();
      }
    });
    this.addCommand({
      id: "analyze-all-res-notes",
      name: "Analyze all notes in movie/series folders for _res poster and update ratings",
      callback: async () => {
        await this.analyzeAllResNotes();
      }
    });
    this.addSettingTab(new ObsidianTMDBSettingTab(this.app, this));
    this.setupFileDeletionListener();
  }
  // Setup file deletion listener to automatically remove associated media files
  setupFileDeletionListener() {
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        if (file instanceof import_obsidian13.TFile) {
          await this.handleFileDeletion(file);
        }
      })
    );
  }
  // Handle file deletion by removing associated media files
  async handleFileDeletion(file) {
    const movieFolderPath = this.settings.movieFolder;
    const seriesFolderPath = this.settings.seriesFolder;
    const isInMovieFolder = movieFolderPath && file.path.startsWith(movieFolderPath);
    const isInSeriesFolder = seriesFolderPath && file.path.startsWith(seriesFolderPath);
    if (!isInMovieFolder && !isInSeriesFolder) {
      return;
    }
    const fileNameWithoutExt = file.basename;
    if (!fileNameWithoutExt) {
      return;
    }
    console.log(`[FileDeletion] Detected deletion of: ${file.path}, looking for associated media files...`);
    const filesToDelete = [];
    const allFiles = this.app.vault.getFiles();
    const searchPattern = new RegExp(`^${this.escapeRegExp(fileNameWithoutExt)}(?:_|-|\\.\\w|$)`, "i");
    for (const vaultFile of allFiles) {
      if ((vaultFile.extension === "jpg" || vaultFile.extension === "jpeg" || vaultFile.extension === "png" || vaultFile.extension === "gif" || vaultFile.extension === "webp") && // Match files that start with the note name or contain it in a meaningful way
      (vaultFile.name.toLowerCase().startsWith(fileNameWithoutExt.toLowerCase()) || vaultFile.name.toLowerCase().includes(fileNameWithoutExt.toLowerCase() + "_") || vaultFile.name.toLowerCase().includes(fileNameWithoutExt.toLowerCase() + "-") || searchPattern.test(vaultFile.name))) {
        filesToDelete.push(vaultFile);
      }
    }
    for (const mediaFile of filesToDelete) {
      try {
        await this.app.vault.delete(mediaFile);
        console.log(`[FileDeletion] Deleted associated media file: ${mediaFile.path}`);
      } catch (error) {
        console.error(`[FileDeletion] Error deleting media file ${mediaFile.path}:`, error);
      }
    }
    if (filesToDelete.length > 0) {
      new import_obsidian13.Notice(`Deleted ${filesToDelete.length} associated media file(s) for: ${fileNameWithoutExt}`);
    }
  }
  // Helper function to escape special regex characters
  escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  // Shows error notification to user
  showNotice(error) {
    try {
      new import_obsidian13.Notice(error.message);
    } catch (e) {
    }
  }
  // Main workflow: search -> select -> create note with template
  async createNewNote() {
    try {
      console.log("[Main] Starting createNewNote");
      const movieShow = await this.searchMovieShow();
      console.log("[Main] Movie/Show received:", {
        id: movieShow.id,
        name: movieShow.name,
        type: movieShow.type,
        isSeries: movieShow.isSeries,
        year: movieShow.year
      });
      const {
        movieFileNameFormat,
        movieFolder,
        seriesFileNameFormat,
        seriesFolder
      } = this.settings;
      const status = movieShow.status || t("status.willWatch");
      movieShow.status = [status];
      const userRating = movieShow.userRating;
      if (userRating !== void 0 && userRating !== null) {
        movieShow.userRating = userRating;
      }
      const finalContents = await this.getRenderedContents(movieShow);
      const fileNameFormat = movieShow.isSeries ? seriesFileNameFormat : movieFileNameFormat;
      const folderPath = movieShow.isSeries ? seriesFolder : movieFolder;
      if (folderPath && !await this.app.vault.adapter.exists(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const fileName = await makeFileName(
        this.app,
        movieShow,
        fileNameFormat,
        folderPath
      );
      console.log("[Main] Creating file:", fileName);
      const filePath = `${folderPath}/${fileName}`;
      const targetFile = await this.app.vault.create(
        filePath,
        finalContents
      );
      const newLeaf = this.app.workspace.getLeaf(true);
      if (!newLeaf) {
        console.warn("No new leaf");
        return;
      }
      await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
      newLeaf.setEphemeralState({ rename: "all" });
      await new CursorJumper(this.app).jumpToNextCursorLocation();
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Add status to content
  addStatusToContent(content, status) {
    const escapedStatus = status.replace(/"/g, '\\"');
    let processedContent = content.replace(/{{status}}/gi, escapedStatus);
    if (processedContent.startsWith("---")) {
      const frontmatterEndIndex = processedContent.indexOf("\n---\n", 3);
      if (frontmatterEndIndex !== -1) {
        const frontmatter = processedContent.substring(0, frontmatterEndIndex + 5);
        const body = processedContent.substring(frontmatterEndIndex + 5);
        const statusPattern = new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i");
        if (frontmatter.match(statusPattern)) {
          const updatedFrontmatter = frontmatter.replace(statusPattern, `${t("common.status")}: "${escapedStatus}"`);
          return `${updatedFrontmatter}${body}`;
        } else {
          const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("common.status")}: "${escapedStatus}"
---
`);
          return `${updatedFrontmatter}${body}`;
        }
      } else {
        const altFrontmatterEndIndex = processedContent.indexOf("---\n", 4);
        if (altFrontmatterEndIndex !== -1) {
          const frontmatter = processedContent.substring(0, altFrontmatterEndIndex + 4);
          const body = processedContent.substring(altFrontmatterEndIndex + 4);
          const statusPattern = new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i");
          if (frontmatter.match(statusPattern)) {
            const updatedFrontmatter = frontmatter.replace(statusPattern, `${t("common.status")}: "${escapedStatus}"`);
            return `${updatedFrontmatter}${body}`;
          } else {
            const updatedFrontmatter = frontmatter.replace("---\n", `---
${t("common.status")}: "${escapedStatus}"
`);
            return `${updatedFrontmatter}${body}`;
          }
        }
      }
    }
    return processedContent;
  }
  // Coordinates search process: search then select from results
  async searchMovieShow() {
    const searchedItems = await this.openSearchModal();
    return await this.openSuggestModal(searchedItems);
  }
  // Opens search modal and returns found items
  async openSearchModal() {
    return new Promise((resolve, reject) => {
      return new SearchModal(this, (error, results) => {
        return error ? reject(error) : resolve(results != null ? results : []);
      }).open();
    });
  }
  // Opens suggestion modal and returns detailed info about selected item
  async openSuggestModal(items) {
    return new Promise((resolve, reject) => {
      return new ItemsSuggestModal(this, items, (error, selectedItem) => {
        return error ? reject(error) : resolve(selectedItem);
      }).open();
    });
  }
  // Loads template content and fills it with movie/series data
  async getRenderedContents(movieShow) {
    const { movieTemplateFile, seriesTemplateFile } = this.settings;
    const templateFile = movieShow.isSeries ? seriesTemplateFile : movieTemplateFile;
    if (templateFile) {
      const templateContents = await getTemplateContents(
        this.app,
        templateFile
      );
      const replacedVariable = replaceVariableSyntax(
        movieShow,
        templateContents
      );
      return replacedVariable;
    }
    return "";
  }
  // Analyzes all notes in configured folders for those with "_res" in poster filename or ""
  // Extracts title and rating, searches TMDB, and creates new notes with user rating - runs in background
  async analyzeAllResNotes() {
    try {
      console.log("[AnalyzeAll] Starting analysis of all _res notes in configured folders");
      const movieFolderPath = this.settings.movieFolder;
      const seriesFolderPath = this.settings.seriesFolder;
      const movieFiles = movieFolderPath ? await this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(movieFolderPath)) : [];
      const seriesFiles = seriesFolderPath && seriesFolderPath !== movieFolderPath ? await this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(seriesFolderPath)) : [];
      const allFiles = [.../* @__PURE__ */ new Set([...movieFiles, ...seriesFiles])];
      console.log(`[AnalyzeAll] Found ${allFiles.length} markdown files in configured folders`);
      if (allFiles.length === 0) {
        new import_obsidian13.Notice("No files found in configured folders.");
        return;
      }
      const progressNotice = new import_obsidian13.Notice(`Analyzing 0/${allFiles.length} files...`, 0);
      let processedCount = 0;
      let errorCount = 0;
      for (const file of allFiles) {
        try {
          const content = await this.app.vault.cachedRead(file);
          if (this.containsResPoster(content)) {
            console.log(`[AnalyzeAll] Found _res poster in file: ${file.path}`);
            await this.processResNoteInBackground(file, content);
            processedCount++;
          }
          progressNotice.setMessage(`Analyzing ${processedCount + errorCount}/${allFiles.length} files...`);
        } catch (error) {
          console.error(`[AnalyzeAll] Error processing file ${file.path}:`, error);
          errorCount++;
          progressNotice.setMessage(`Analyzing ${processedCount + errorCount}/${allFiles.length} files... (${errorCount} errors)`);
        }
      }
      progressNotice.hide();
      new import_obsidian13.Notice(`Mass analysis completed! Processed: ${processedCount}, Errors: ${errorCount}`);
      console.log(`[AnalyzeAll] Mass analysis completed! Processed: ${processedCount}, Errors: ${errorCount}`);
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Process a note in background without opening it
  async processResNoteInBackground(file, content) {
    console.log(`[ProcessBg] Processing file in background: ${file.path}`);
    const title = this.extractTitle(file.basename, content);
    const rating = this.extractRating(content);
    const hasUserRating = new RegExp(`${t("ratings.myRating")}:\\s*\\d+\\.?\\d*`, "i").test(content);
    const customStatus = this.extractCustomStatus(content);
    const yearFromFile = this.extractYearFromFile(file.basename);
    const yearFromContent = this.extractYear(content);
    const year = yearFromFile || yearFromContent;
    console.log(`[ProcessBg] Extracted title: ${title}, rating: ${rating}, hasUserRating: ${hasUserRating}, status: ${customStatus}, year: ${year}`);
    if (title) {
      const searchResults = await this.searchOnTMDB(title);
      if (searchResults && searchResults.length > 0) {
        const bestMatch = this.findBestMatch(searchResults, title, year);
        if (bestMatch) {
          console.log(`[ProcessBg] Best match found: ${bestMatch.name}`);
          await this.createNoteWithRatingInBackground(file, bestMatch, rating, customStatus, hasUserRating);
        }
      }
    }
  }
  // Create a new note in background without opening it
  async createNoteWithRatingInBackground(originalFile, item, userRating, customStatus = null, hasUserRating = false) {
    if (!item || !this.settings.apiToken) {
      return;
    }
    try {
      const originalPath = originalFile.path;
      const lastSlashIndex = originalPath.lastIndexOf("/");
      const lastSlashIndexWin = originalPath.lastIndexOf("\\");
      const lastSlashPos = Math.max(lastSlashIndex, lastSlashIndexWin);
      const folderPath = originalPath.substring(0, lastSlashPos + 1);
      const fileNameWithExt = originalPath.substring(lastSlashPos + 1);
      const lastDotIndex = fileNameWithExt.lastIndexOf(".");
      const baseName = fileNameWithExt.substring(0, lastDotIndex);
      const extension = fileNameWithExt.substring(lastDotIndex + 1);
      const newPath = folderPath + baseName + "_old." + extension;
      await this.app.fileManager.renameFile(originalFile, newPath);
      console.log(`[RenameBg] Renamed original file to: ${newPath}`);
      const provider2 = new TMDBProvider();
      let movieShow = await provider2.getMovieById(item.id, this.settings.apiToken, item.type, userRating != null ? userRating : void 0);
      if (this.settings.saveImagesLocally) {
        const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
        movieShow = await processImages2(
          this.app,
          movieShow,
          {
            saveImagesLocally: this.settings.saveImagesLocally,
            imagesFolder: this.settings.imagesFolder,
            savePosterImage: this.settings.savePosterImage,
            saveCoverImage: this.settings.saveCoverImage,
            saveLogoImage: this.settings.saveLogoImage,
            imageFileNameFormat: this.settings.imageFileNameFormat
          }
        );
      }
      if (userRating !== null && userRating !== void 0 && userRating !== "") {
        movieShow.userRating = userRating;
      }
      if (customStatus) {
        movieShow.status = [customStatus];
      } else {
        movieShow.status = [t("status.willWatch")];
      }
      const targetFolderPath = item.type === "tv-series" ? this.settings.seriesFolder : this.settings.movieFolder;
      if (targetFolderPath && !await this.app.vault.adapter.exists(targetFolderPath)) {
        await this.app.vault.createFolder(targetFolderPath);
      }
      let renderedContents = await this.getRenderedContents(movieShow);
      if (customStatus !== null) {
        const escapedStatus = customStatus.replace(/"/g, '\\"');
        renderedContents = renderedContents.replace(new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i"), `${t("common.status")}: "${escapedStatus}"`);
      }
      if (userRating !== null && hasUserRating) {
        if (!renderedContents.includes("{{userRating}}")) {
          if (renderedContents.startsWith("---")) {
            const frontmatterEndIndex = renderedContents.indexOf("\n---\n", 3);
            if (frontmatterEndIndex !== -1) {
              const frontmatter = renderedContents.substring(0, frontmatterEndIndex + 5);
              const body = renderedContents.substring(frontmatterEndIndex + 5);
              if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("ratings.myRating")}: ${userRating}
---
`);
                renderedContents = `${updatedFrontmatter}${body}`;
              }
            } else {
              const altFrontmatterEndIndex = renderedContents.indexOf("---\n", 4);
              if (altFrontmatterEndIndex !== -1) {
                const frontmatter = renderedContents.substring(0, altFrontmatterEndIndex + 4);
                const body = renderedContents.substring(altFrontmatterEndIndex + 4);
                if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                  const updatedFrontmatter = frontmatter.replace("---\n", `${t("ratings.myRating")}: ${userRating}
---
`);
                  renderedContents = `${updatedFrontmatter}${body}`;
                }
              } else {
                renderedContents = renderedContents.replace("---", `---
${t("ratings.myRating")}: ${userRating}`);
              }
            }
          } else {
            renderedContents = `---
${t("ratings.myRating")}: ${userRating}
---

${renderedContents}`;
          }
        }
      }
      const originalFileName = baseName.replace("_old", "") + "." + extension;
      const newFilePath = `${targetFolderPath}/${originalFileName}`;
      const targetFile = await this.app.vault.create(
        newFilePath,
        renderedContents
      );
      console.log(`[CreateBg] Created updated note with user rating: ${newFilePath}`);
    } catch (error) {
      console.error("[Update NoteBg] Error updating note with rating:", error);
      this.showNotice(new Error(`Error updating note: ${error.message}`));
    }
  }
  // Analyzes the current active note for "_res" in poster filename
  // Extracts title and rating, searches TMDB, and creates new notes with user rating
  async analyzeResNotes() {
    try {
      console.log("[Analyze] Starting analysis of current note for _res poster");
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile || activeFile.extension !== "md") {
        new import_obsidian13.Notice("Please open a markdown note to analyze");
        return;
      }
      const content = await this.app.vault.cachedRead(activeFile);
      console.log(`[Analyze] Analyzing current file: ${activeFile.path}`);
      if (this.containsResPoster(content)) {
        console.log(`[Analyze] Found _res poster in current file`);
        await this.processResNote(activeFile, content);
        new import_obsidian13.Notice(`Found and processed _res note: ${activeFile.basename}`);
      } else {
        new import_obsidian13.Notice(`Current note does not contain _res poster: ${activeFile.basename}`);
        console.log(`[Analyze] Current file does not contain _res poster`);
      }
    } catch (err) {
      console.warn(err);
      this.showNotice(err);
    }
  }
  // Check if content contains "_res" in poster filename or ""
  containsResPoster(content) {
    const resPattern = /(!\[\[.*_res|!\[.*\]\(.*_res|poster.*_res|cover.*_res|_resources)/i;
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*\\d+\\.?\\d*`, "i");
    return resPattern.test(content) || kinopoiskPattern.test(content);
  }
  // Process a note that contains "_res" in poster filename
  async processResNote(file, content) {
    console.log(`[Process] Processing file: ${file.path}`);
    const title = this.extractTitle(file.basename, content);
    const rating = this.extractRating(content);
    const hasUserRating = new RegExp(`${t("ratings.myRating")}:\\s*\\d+\\.?\\d*`, "i").test(content);
    const customStatus = this.extractCustomStatus(content);
    const yearFromFile = this.extractYearFromFile(file.basename);
    const yearFromContent = this.extractYear(content);
    const year = yearFromFile || yearFromContent;
    console.log(`[Process] Extracted title: ${title}, rating: ${rating}, hasUserRating: ${hasUserRating}, status: ${customStatus}, year: ${year}`);
    if (title) {
      const searchResults = await this.searchOnTMDB(title);
      if (searchResults && searchResults.length > 0) {
        const bestMatch = this.findBestMatch(searchResults, title, year);
        if (bestMatch) {
          console.log(`[Process] Best match found: ${bestMatch.name}`);
          await this.createNoteWithRating(bestMatch, rating, customStatus, hasUserRating);
        }
      }
    }
  }
  // Extract title from filename or content
  extractTitle(basename, content) {
    const filenameTitle = basename.replace(/\s*\(\d{4}\).*/, "").trim();
    if (filenameTitle) return filenameTitle;
    const titleMatch = content.match(/title:\s*["']?([^"'\n]+)/i);
    if (titleMatch) return titleMatch[1].trim();
    const nameMatch = content.match(/name:\s*["']?([^"'\n]+)/i);
    if (nameMatch) return nameMatch[1].trim();
    return "";
  }
  // Extract year from filename or content
  extractYearFromFile(basename) {
    const yearMatch = basename.match(/\((\d{4})\)/);
    if (yearMatch && yearMatch[1]) {
      return parseInt(yearMatch[1]);
    }
    return null;
  }
  // Extract rating from content - prioritize user rating over Kinopoisk rating
  extractRating(content) {
    const userRatingPatterns = [
      new RegExp(`${t("ratings.myRating")}:\\s*(\\d+\\.?\\d*)`, "i"),
      // Localized "MyRating" - highest priority
      /rating:\s*(\d+\.?\d*)/i,
      /user_rating:\s*(\d+\.?\d*)/i,
      /my_rating:\s*(\d+\.?\d*)/i,
      /:\s*(\d+\.?\d*)/i,
      // Russian for "rating"
      /:\s*(\d+\.?\d*)/i
      // Russian for "rating"
    ];
    for (const pattern of userRatingPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        const rating = parseFloat(match[1]);
        if (!isNaN(rating)) {
          return rating;
        }
      }
    }
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*(\\d+\\.?\\d*)`, "i");
    const kinopoiskMatch = content.match(kinopoiskPattern);
    if (kinopoiskMatch && kinopoiskMatch[1]) {
      const rating = parseFloat(kinopoiskMatch[1]);
      if (!isNaN(rating)) {
        return rating;
      }
    }
    return null;
  }
  // Extract custom status from content
  extractCustomStatus(content) {
    const statusPatterns = [
      new RegExp(`${t("common.status")}:\\s*["']?([^"'
,]+)`, "i"),
      // Localized "Status"
      /status:\s*["']?([^"'\n,]+)/i
    ];
    for (const pattern of statusPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }
    return null;
  }
  // Extract Kinopoisk rating from content
  extractKinopoiskRating(content) {
    const kinopoiskPattern = new RegExp(`${t("ratings.kinopoiskRating")}:\\s*(\\d+\\.?\\d*)`, "i");
    const match = content.match(kinopoiskPattern);
    if (match && match[1]) {
      const rating = parseFloat(match[1]);
      if (!isNaN(rating)) {
        return rating;
      }
    }
    return null;
  }
  // Extract year from content
  extractYear(content) {
    const yearPatterns = [
      new RegExp(`${t("ratings.year")}:\\s*(\\d{4})`, "i"),
      // Localized "Year"
      /year:\s*(\d{4})/i,
      /release_date.*?(\d{4})/i,
      /\b(19|20)\d{2}\b/
      // More specific 4-digit year pattern (19xx-20xx)
    ];
    for (const pattern of yearPatterns) {
      const match = content.match(pattern);
      if (match && match[0] && /^\d{4}$/.test(match[0])) {
        return parseInt(match[0]);
      }
    }
    return null;
  }
  // Search TMDB for a title
  async searchOnTMDB(title) {
    if (!title || !this.settings.apiToken) {
      return null;
    }
    try {
      const provider2 = new TMDBProvider();
      return await provider2.searchByQuery(title, this.settings.apiToken);
    } catch (error) {
      console.error(`[TMDB Search] Error searching for "${title}":`, error);
      return null;
    }
  }
  // Find the best matching result based on title and year
  findBestMatch(results, title, year) {
    if (!results || results.length === 0) {
      return null;
    }
    const exactTitleMatches = results.filter(
      (item) => item.name.toLowerCase() === title.toLowerCase() || item.alternativeName.toLowerCase() === title.toLowerCase()
    );
    if (exactTitleMatches.length > 0) {
      if (year) {
        const exactMatchWithYear = exactTitleMatches.find((item) => item.year === year);
        if (exactMatchWithYear) return exactMatchWithYear;
        const closeYearMatch = exactTitleMatches.find(
          (item) => item.year > 0 && Math.abs(item.year - year) <= 1
        );
        if (closeYearMatch) return closeYearMatch;
      }
      return exactTitleMatches[0];
    }
    const fuzzyMatches = results.filter(
      (item) => item.name.toLowerCase().includes(title.toLowerCase()) || item.alternativeName.toLowerCase().includes(title.toLowerCase())
    );
    if (fuzzyMatches.length > 0) {
      if (year) {
        const fuzzyMatchWithYear = fuzzyMatches.find((item) => item.year === year);
        if (fuzzyMatchWithYear) return fuzzyMatchWithYear;
        const closeFuzzyYearMatch = fuzzyMatches.find(
          (item) => item.year > 0 && Math.abs(item.year - year) <= 1
        );
        if (closeFuzzyYearMatch) return closeFuzzyYearMatch;
      }
      return fuzzyMatches[0];
    }
    return results[0];
  }
  // Update the original note with TMDB data and user rating
  async createNoteWithRating(item, userRating, customStatus = null, hasUserRating = false) {
    if (!item || !this.settings.apiToken) {
      return;
    }
    try {
      const updateNotice = new import_obsidian13.Notice(`Updating: ${item.name}`, 0);
      const originalFile = this.app.workspace.getActiveFile();
      if (!originalFile) {
        console.error("[Update Note] No active file found");
        updateNotice.hide();
        return;
      }
      const originalContent = await this.app.vault.read(originalFile);
      const originalPath = originalFile.path;
      const lastSlashIndex = originalPath.lastIndexOf("/");
      const lastSlashIndexWin = originalPath.lastIndexOf("\\");
      const lastSlashPos = Math.max(lastSlashIndex, lastSlashIndexWin);
      const folderPath = originalPath.substring(0, lastSlashPos + 1);
      const fileNameWithExt = originalPath.substring(lastSlashPos + 1);
      const lastDotIndex = fileNameWithExt.lastIndexOf(".");
      const baseName = fileNameWithExt.substring(0, lastDotIndex);
      const extension = fileNameWithExt.substring(lastDotIndex + 1);
      const newPath = folderPath + baseName + "_old." + extension;
      await this.app.fileManager.renameFile(originalFile, newPath);
      console.log(`[Rename] Renamed original file to: ${newPath}`);
      updateNotice.setMessage(`Renamed to: ${baseName}_old.${extension}`);
      const provider2 = new TMDBProvider();
      let movieShow = await provider2.getMovieById(item.id, this.settings.apiToken, item.type, userRating != null ? userRating : void 0);
      updateNotice.setMessage(`Retrieved TMDB data for: ${item.name}`);
      if (this.settings.saveImagesLocally) {
        const { processImages: processImages2 } = await Promise.resolve().then(() => (init_imageUtils(), imageUtils_exports));
        const imageNotice = new import_obsidian13.Notice("Processing images...", 0);
        movieShow = await processImages2(
          this.app,
          movieShow,
          {
            saveImagesLocally: this.settings.saveImagesLocally,
            imagesFolder: this.settings.imagesFolder,
            savePosterImage: this.settings.savePosterImage,
            saveCoverImage: this.settings.saveCoverImage,
            saveLogoImage: this.settings.saveLogoImage,
            imageFileNameFormat: this.settings.imageFileNameFormat
          },
          (current, total, currentTask) => {
            if (total > 0) {
              imageNotice.setMessage(`Images: ${current}/${total}`);
            } else {
              imageNotice.setMessage(currentTask);
            }
          }
        );
        imageNotice.hide();
        new import_obsidian13.Notice("Images processed!");
      }
      if (userRating !== null && userRating !== void 0 && userRating !== "") {
        movieShow.userRating = userRating;
      }
      if (customStatus) {
        movieShow.status = [customStatus];
      } else {
        movieShow.status = [t("status.willWatch")];
      }
      const targetFolderPath = item.type === "tv-series" ? this.settings.seriesFolder : this.settings.movieFolder;
      if (targetFolderPath && !await this.app.vault.adapter.exists(targetFolderPath)) {
        await this.app.vault.createFolder(targetFolderPath);
      }
      let renderedContents = await this.getRenderedContents(movieShow);
      updateNotice.setMessage(`Rendering template...`);
      if (userRating !== null && hasUserRating) {
        if (!renderedContents.includes("{{userRating}}")) {
          if (renderedContents.startsWith("---")) {
            const frontmatterEndIndex = renderedContents.indexOf("\n---\n", 3);
            if (frontmatterEndIndex !== -1) {
              const frontmatter = renderedContents.substring(0, frontmatterEndIndex + 5);
              const body = renderedContents.substring(frontmatterEndIndex + 5);
              if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                const updatedFrontmatter = frontmatter.replace("\n---\n", `
${t("ratings.myRating")}: ${userRating}
---
`);
                renderedContents = `${updatedFrontmatter}${body}`;
              }
            } else {
              const altFrontmatterEndIndex = renderedContents.indexOf("---\n", 4);
              if (altFrontmatterEndIndex !== -1) {
                const frontmatter = renderedContents.substring(0, altFrontmatterEndIndex + 4);
                const body = renderedContents.substring(altFrontmatterEndIndex + 4);
                if (!frontmatter.includes(`${t("ratings.myRating")}:`)) {
                  const updatedFrontmatter = frontmatter.replace("---\n", `${t("ratings.myRating")}: ${userRating}
---
`);
                  renderedContents = `${updatedFrontmatter}${body}`;
                }
              } else {
                renderedContents = renderedContents.replace("---", `---
${t("ratings.myRating")}: ${userRating}`);
              }
            }
          } else {
            renderedContents = `---
${t("ratings.myRating")}: ${userRating}
---

${renderedContents}`;
          }
        }
      }
      if (customStatus !== null) {
        const escapedStatus = customStatus.replace(/"/g, '\\"');
        renderedContents = renderedContents.replace(new RegExp(`${t("common.status")}:\\s*["']?([^"'
,}]+)["']?`, "i"), `${t("common.status")}: "${escapedStatus}"`);
      }
      const originalFileName = baseName.replace("_old", "") + "." + extension;
      const newFilePath = `${targetFolderPath}/${originalFileName}`;
      const targetFile = await this.app.vault.create(
        newFilePath,
        renderedContents
      );
      console.log(`[Create] Created updated note with user rating: ${newFilePath}`);
      updateNotice.setMessage(`Creating note...`);
      const newLeaf = this.app.workspace.getLeaf(true);
      if (newLeaf) {
        await newLeaf.openFile(targetFile, { state: { mode: "preview" } });
        updateNotice.setMessage(`Opening: ${originalFileName}`);
      }
      updateNotice.hide();
      new import_obsidian13.Notice(`\u2705 Updated: ${originalFileName}`);
    } catch (error) {
      console.error("[Update Note] Error updating note with rating:", error);
      this.showNotice(new Error(`Error updating note: ${error.message}`));
    }
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
